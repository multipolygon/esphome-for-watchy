## ESPHome for Watchy ##
# https://watchy.sqfmi.com/docs/hardware

substitutions:
  # https://esphome.io/guides/configuration-types.html#substitutions
  <<: !include config.yaml
  <<: !include pins-v3.yaml
  <<: !include mdi.yaml
  ID: "1"
  NAME: watchy-v$VERSION-id$ID
  #### FACES AND MODES ####
  FACE_COUNT: "9"
  MODE_FACES: "0"
  MODE_TIMERS: "1"
  MODE_MENU: "2"
  MODE_QR: "3"

logger:
  # https://esphome.io/components/logger.html#log-levels
  level: NONE

esphome:
  # https://esphome.io/components/esphome.html#esphome-core-configuration
  name: $NAME
  includes:
    - mdi.h
    - icons.h
  on_boot:
    then:
      - delay: 1ms
      # - pcf8563.read_time: # Only for Watchy v2
      - component.update: battery
      - lambda: |-
          randomSeed(esp_random());
          const auto now = id(ntp).now();
          const auto utcnow = id(ntp).utcnow();

          id(alarm_buzzing) =
            (now.minute == 0 || id(power_saving_mode).state) && (
              id(alarm_a_enable).state && int(id(alarm_a_hour).state) == now.hour ||
              id(alarm_b_enable).state && int(id(alarm_b_hour).state) == now.hour
            );

          if (id(alarm_buzzing) || esp_sleep_get_wakeup_cause() != ESP_SLEEP_WAKEUP_TIMER) {
            id(keep_awake) = true;
          }

          if (!id(power_saving_mode).state) {
            id(chime) = now.minute == 0 && (now.hour == 8 || now.hour == 12 || now.hour == 16);

            if ((utcnow.hour % 3 == 0 && utcnow.minute == 0) || esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_UNDEFINED) {
              id(updating_weather) = true;
              id(wifi_id).enable();
            } else if (!id(keep_awake) && id(mode) == $MODE_FACES) {
              if (random(1000) == 0) {
                id(chime) = true;
                id(mode) = id(mode) + 1000;
              }
            }
          }

          if (id(keep_awake) || id(alarm_buzzing) || id(chime)) {
            id(buzzer).turn_on();
          }

          if (id(mode) == $MODE_MENU) {
            id(mode) = $MODE_FACES;
          }

          id(epaper).update();
          id(buzzer).turn_off();
          id(go_to_sleep).execute();

display:
  # Configuration for the display
  # https://esphome.io/components/display/
  # https://esphome.io/components/display/waveshare_epaper.html
  # https://www.good-display.com/product/206.html
  # https://www.e-paper-display.com/products_detail/productId=455.html
  - id: epaper
    platform: waveshare_epaper
    model: 1.54inv2
    cs_pin: $DISPLAY_CS_PIN
    dc_pin: $DISPLAY_DC_PIN
    reset_pin: $DISPLAY_RES_PIN
    busy_pin: $DISPLAY_BUSY_PIN
    update_interval: never
    # Problem: full_update_every does not work as expected because esphome code will do a full update on every boot up.
    # Solution: Edited `waveshare_epaper.h` and initialise to 1 instead of 0: `uint32_t at_update_{1};`
    # See: `external_components` near the bottom.
    full_update_every: 1000
    # Duration for the display reset operation. Defaults to 200ms. Setting this value to 2ms may resolve issues with newer e-Paper Driver modules (e.g. Rev 2.1).
    reset_duration: 2ms # ?????
    lambda: |-
      const auto w = it.get_width();
      const auto h = it.get_height();

      const auto now = id(ntp).now();
      const auto epochTime = id(ntp).utcnow().timestamp;
      const auto weatherExpiryTime = id(weather_times)[3];

      const auto m = now.month;
      const auto d = now.day_of_month;
      const auto md = m * 100 + d;
      const auto FRIDAY = 6;

      const char *wifiIcon = id(keep_awake) ?
        (id(wifi_id).is_disabled() ? mdiEmoticonHappyOutline : (id(wifi_id).is_connected() ? mdiWifi  : mdiWifiOff)) :
        (id(power_saving_mode).state ? mdiSleep : "");

      const char *alarmEnabledIcon = id(alarm_a_enable).state || id(alarm_b_enable).state ? mdiAlarmCheck : "";

      const char *batteryIcon = id(is_charging).state ? mdiBatteryChargingHigh : (
        !id(battery).has_state() ? mdiBatteryRemoveOutline : (
          id(battery).state > $BATTERY_FULL ? mdiBatteryHigh : (
            id(battery).state > $BATTERY_HIGH ? mdiBatteryMedium : (
              id(battery).state > $BATTERY_LOW ? mdiBatteryLow :
                mdiBatteryOutline
            )
          )
        )
      );

      const char *alertIcon =
        id(alarm_buzzing) ? mdiBellRingOutline :
        id(chime) ? mdiBellOutline :
        "";

      const char *calendarIcon = "";
      if (
        m == $BIRTHMONTH && d == $BIRTHDAY ||
        m == $BIRTHMONTH1 && d == $BIRTHDAY1 ||
        m == $BIRTHMONTH2 && d == $BIRTHDAY2
      ) {
        calendarIcon = mdiCakeVariantOutline;
      } else if (calendarIcons.find(md) != calendarIcons.end()) {
        calendarIcon = calendarIcons[md];
      } else if (now.day_of_year == 256) {
        calendarIcon = mdiCodeBraces;
      } else if (now.day_of_week == FRIDAY && d == 13) {
        calendarIcon = mdiClover;
      }

      if (id(mode) == $MODE_FACES) {
        const int FACE_DIGITAL = 0;
        const int FACE_HANDS_ARABIC = 1;
        const int FACE_HANDS_ARABIC_SMALL = 2;
        const int FACE_HANDS_ROMAN = 3;
        const int FACE_HANDS_ROMAN_SMALL = 4;
        const int FACE_HANDS_24_HOUR = 5;
        const int FACE_HANDS_24_HOUR_SMALL = 6;
        const int FACE_HUGE_WEATHER_ICON = 7;
        const int FACE_QUAD_WEATHER_ICONS = 8;
        const int FACE_INFO_DEBUG = 9;

        if (id(face) == FACE_DIGITAL) {

          // Date //
          it.strftime(w/2, 0, id(date_font), TextAlign::TOP_CENTER, "%a %d %b", now);

          // Time //
          if (now.hour <= 9) {
            it.printf(0, h/2, id(mdi), TextAlign::CENTER_LEFT, "%s", calendarIcon);
          }
          it.printf(w/2-10, h/2, id(time_font), TextAlign::CENTER_RIGHT, "%d", now.hour);
          it.print(w/2, h/2-5, id(time_font), TextAlign::CENTER, ":");
          if (!id(power_saving_mode).state) {
            it.printf(w/2+10, h/2, id(time_font), TextAlign::CENTER_LEFT, "%02d", now.minute);
          }

          // Weather //
          if (id(weather_temp_max) != -1000.0 && epochTime <= weatherExpiryTime) {
            it.printf(0, h, id(date_font), TextAlign::BOTTOM_LEFT, "%.0fÂ°", id(weather_temp_max));
          }
          it.printf(w, h, id(mdi_weather), TextAlign::BOTTOM_RIGHT, "%s%s%s%s",
            epochTime <= id(weather_times)[0] ? weatherIcons[id(weather_codes)[0]] : "",
            epochTime <= id(weather_times)[1] ? weatherIcons[id(weather_codes)[1]] : "",
            epochTime <= id(weather_times)[2] ? weatherIcons[id(weather_codes)[2]] : "",
            epochTime <= id(weather_times)[3] ? weatherIcons[id(weather_codes)[3]] : ""
          );

          // Status Icons //
          it.printf(w/2, h/2+46, id(mdi_small), TextAlign::CENTER, "%s%s%s%s", alertIcon, wifiIcon, batteryIcon, alarmEnabledIcon);

          // Active Timer //
          if (id(timers)[id(active_timer)] != 0) {
            int activeTimer = epochTime - id(timers)[id(active_timer)];
            if (activeTimer < 48 * 60 * 60) { // Limit to 48 hours
              it.printf(w/2, h/2-46, id(small_font), TextAlign::CENTER,
                "%dh %02dm",
                (activeTimer) / (60*60),
                id(power_saving_mode).state ? 0 : ((activeTimer / 60) % 60)
              );
            } else {
              it.printf(w/2, h/2-46, id(small_font), TextAlign::CENTER,
                "%dd %dh %02dm",
                activeTimer / (24*60*60),
                (activeTimer % (24*60*60)) / (60*60),
                id(power_saving_mode).state ? 0 : ((activeTimer / 60) % 60)
              );
            }
          } else {
            const float metricTime = ((float(now.hour) * 60.0 * 60.0 + float(now.minute) * 60.0 + float(now.second)) / 86400.0) * 10000.0;
            it.printf(w/2, h/2-46, id(small_font), TextAlign::CENTER, "%.0f", metricTime);
          }

        } else if (
          id(face) == FACE_HANDS_ARABIC ||
          id(face) == FACE_HANDS_ARABIC_SMALL ||
          id(face) == FACE_HANDS_ROMAN ||
          id(face) == FACE_HANDS_ROMAN_SMALL ||
          id(face) == FACE_HANDS_24_HOUR ||
          id(face) == FACE_HANDS_24_HOUR_SMALL
        )
        {

          const bool n = id(face) == FACE_HANDS_ARABIC ||
                         id(face) == FACE_HANDS_ARABIC_SMALL ||
                         id(face) == FACE_HANDS_24_HOUR ||
                         id(face) == FACE_HANDS_24_HOUR_SMALL;
          const bool s = id(face) == FACE_HANDS_ARABIC_SMALL ||
                         id(face) == FACE_HANDS_ROMAN_SMALL ||
                         id(face) == FACE_HANDS_24_HOUR_SMALL;
          const bool hr24 = id(face) == FACE_HANDS_24_HOUR ||
                            id(face) == FACE_HANDS_24_HOUR_SMALL;

          // Center Dot //
          it.filled_circle(w/2, w/2, 5);

          // Big Marks //
          const auto bigFont = s ? id(small_font) : id(date_font);

          if (hr24) {
            it.print(w, h/2, bigFont, TextAlign::CENTER_RIGHT, n ? "18" : "XVIII");
            it.print(w/2, h+(s ? 0 : 6), bigFont, TextAlign::BOTTOM_CENTER, n ? "0" : "O");
            it.print(0, h/2, bigFont, TextAlign::CENTER_LEFT, n ? "6" : "VI");
            it.print(w/2, 0-(s ? 0 : 8), bigFont, TextAlign::TOP_CENTER, n ? "12" : "XII");
          } else {
            it.print(w, h/2, bigFont, TextAlign::CENTER_RIGHT, n ? "3" : "III");
            it.print(w/2, h+(s ? 0 : 6), bigFont, TextAlign::BOTTOM_CENTER, n ? "6" : "VI");
            it.print(0, h/2, bigFont, TextAlign::CENTER_LEFT, n ? "9" : "IX");
            it.print(w/2, 0-(s ? 0 : 8), bigFont, TextAlign::TOP_CENTER, n ? "12" : "XII");
          }

          // Small Marks //
          if (hr24) {
            it.print(getClkX24(1), getClkY24(1), id(small_font), TextAlign::CENTER, s ? "." : "1");
            it.print(getClkX24(2), getClkY24(2), id(small_font), TextAlign::CENTER, s ? "." : "2");
            it.print(getClkX24(3), getClkY24(3), id(small_font), TextAlign::CENTER, s ? "." : "3");
            it.print(getClkX24(4), getClkY24(4), id(small_font), TextAlign::CENTER, s ? "." : "4");
            it.print(getClkX24(5), getClkY24(5), id(small_font), TextAlign::CENTER, s ? "." : "5");

            it.print(getClkX24(7), getClkY24(7), id(small_font), TextAlign::CENTER, s ? "." : "7");
            it.print(getClkX24(8), getClkY24(8), id(small_font), TextAlign::CENTER, s ? "." : "8");
            it.print(getClkX24(9), getClkY24(9), id(small_font), TextAlign::CENTER, s ? "." : "9");
            it.print(getClkX24(10), getClkY24(10), id(small_font), TextAlign::CENTER, s ? "." : "10");
            it.print(getClkX24(11), getClkY24(11), id(small_font), TextAlign::CENTER, s ? "." : "11");

            it.print(getClkX24(13), getClkY24(13), id(small_font), TextAlign::CENTER, s ? "." : "13");
            it.print(getClkX24(14), getClkY24(14), id(small_font), TextAlign::CENTER, s ? "." : "14");
            it.print(getClkX24(15), getClkY24(15), id(small_font), TextAlign::CENTER, s ? "." : "15");
            it.print(getClkX24(16), getClkY24(16), id(small_font), TextAlign::CENTER, s ? "." : "16");
            it.print(getClkX24(17), getClkY24(17), id(small_font), TextAlign::CENTER, s ? "." : "17");

            it.print(getClkX24(19), getClkY24(19), id(small_font), TextAlign::CENTER, s ? "." : "19");
            it.print(getClkX24(20), getClkY24(20), id(small_font), TextAlign::CENTER, s ? "." : "20");
            it.print(getClkX24(21), getClkY24(21), id(small_font), TextAlign::CENTER, s ? "." : "21");
            it.print(getClkX24(22), getClkY24(22), id(small_font), TextAlign::CENTER, s ? "." : "22");
            it.print(getClkX24(23), getClkY24(23), id(small_font), TextAlign::CENTER, s ? "." : "23");
          } else {
            it.print(getClkX(1), getClkY(1), id(small_font), TextAlign::CENTER, s ? "." : n ? "1" : "I");
            it.print(getClkX(2), getClkY(2), id(small_font), TextAlign::CENTER, s ? "." : n ? "2" : "II");
            it.print(getClkX(4), getClkY(4), id(small_font), TextAlign::CENTER, s ? "." : n ? "4" : "IV");
            it.print(getClkX(5), getClkY(5), id(small_font), TextAlign::CENTER, s ? "." : n ? "5" : "V");
            it.print(getClkX(7), getClkY(7), id(small_font), TextAlign::CENTER, s ? "." : n ? "7" : "VII");
            it.print(getClkX(8), getClkY(8), id(small_font), TextAlign::CENTER, s ? "." : n ? "8" : "VIII");
            it.print(getClkX(10), getClkY(10), id(small_font), TextAlign::CENTER, s ? "." : n ? "10" : "X");
            it.print(getClkX(11), getClkY(11), id(small_font), TextAlign::CENTER, s ? "." : n ? "11" : "XI");
          }

          // Weather Temp //
          if (id(weather_temp_max) != -1000.0 && epochTime <= weatherExpiryTime) {
            it.printf(w/2, h/2 - 30, id(small_font), TextAlign::BOTTOM_CENTER, "%.0fÂ° to %.0fÂ°", id(weather_temp_min), id(weather_temp_max));
          }

          // Date //
          it.strftime(w/2, h/2 + 30, id(small_font), TextAlign::TOP_CENTER, "%a %d %b", now);

          // Hour Hand //
          double hr = ((now.hour % (hr24 ? 24 : 12) + now.minute / 60.0) / (hr24 ? 24.0 : 12.0) * 360.0 + (hr24 ? 90.0 : -90.0)) * (M_PI / 180.0);
          for (int x=-2; x<=2; ++x) {
            for (int y=-2; y<=2; ++y) {
              it.line(w/2 +x, h/2 +y, w/2.0 + w/3.5 * cos(hr) +x, h/2.0 + h/3.5 * sin(hr) +y);
            }
          }

          // Minute Hand //
          if (!id(power_saving_mode).state) {
            double mn = (now.minute / 60.0 * 360.0 - 90.0) * (M_PI / 180.0);
            for (int x=-1; x<=1; ++x) {
              for (int y=-1; y<=1; ++y) {
                it.line(w/2 +x, h/2 +y, w/2.0 + w/2.5 * cos(mn) +x, h/2.0 + h/2.5 * sin(mn) +y);
              }
            }
          }

          // Weather Icons //
          int offset = 0;
          for (int x=0; x<=3; ++x) {
            if (epochTime > id(weather_times)[x]) {
              offset = x + 1;
            }
          }
          int x = rotateWeatherCode(0, now.hour) + offset;
          if (x <= 3 && epochTime <= id(weather_times)[x]) {
            it.printf(w, 0, id(mdi_weather), TextAlign::TOP_RIGHT, "%s", weatherIcons[id(weather_codes)[x]]);
          }
          x = rotateWeatherCode(1, now.hour) + offset;
          if (x <= 3 && epochTime <= id(weather_times)[x]) {
            it.printf(w, h, id(mdi_weather), TextAlign::BOTTOM_RIGHT, "%s", weatherIcons[id(weather_codes)[x]]);
          }
          x = rotateWeatherCode(2, now.hour) + offset;
          if (x <= 3 && epochTime <= id(weather_times)[x]) {
            it.printf(0, h, id(mdi_weather), TextAlign::BOTTOM_LEFT, "%s", weatherIcons[id(weather_codes)[x]]);
          }
          x = rotateWeatherCode(3, now.hour) + offset;
          if (x <= 3 && epochTime <= id(weather_times)[x]) {
            it.printf(0, 0, id(mdi_weather), TextAlign::TOP_LEFT, "%s", weatherIcons[id(weather_codes)[x]]);
          }

          // Status Icons //
          it.printf(w*1/4, h/2, id(mdi_small), TextAlign::CENTER, "%s%s", alertIcon, wifiIcon);
          it.printf(w*3/4, h/2, id(mdi_small), TextAlign::CENTER, "%s%s", batteryIcon, alarmEnabledIcon);

        } else if (id(face) == FACE_INFO_DEBUG) {

          it.printf(w/2 - 22, 0, id(mdi_weather), TextAlign::TOP_RIGHT, "%s%s",
            weatherIcons[id(weather_codes)[0]],
            weatherIcons[id(weather_codes)[1]]
          );

          it.printf(w/2, 0, id(mdi), TextAlign::TOP_CENTER, "%s",
            sky[random(skyLen)]
          );

          it.printf(w/2 + 22, 0, id(mdi_weather), TextAlign::TOP_LEFT, "%s%s",
            weatherIcons[id(weather_codes)[2]],
            weatherIcons[id(weather_codes)[3]]
          );

          int l = 34;
          const int lh = 18;
          const auto f = id(small_font);

          it.print(0, l, f, TextAlign::TOP_LEFT, "$NAME");
          l += lh;

          it.strftime(0, l, f, TextAlign::TOP_LEFT , "%H:%M %a %d %b", now);
          l += lh;

          if (id(weather_temp_max) != -1000.0) {
            it.printf(0, l, f, TextAlign::TOP_LEFT, "%.0fÂ° to %.0fÂ° (t%+.1fh)",
              id(weather_temp_min), id(weather_temp_max),
              float(epochTime - id(weather_times)[0]) / 60.0 / 60.0
            );
          }
          l += lh;

          it.printf(0, l, f, TextAlign::TOP_LEFT,
            "Wifi: %s (%d)",
            (id(wifi_id).is_disabled() ? (id(keep_awake) ? "off-awake" : "off-sleep") : (id(wifi_id).is_connected() ? id(wifi_id).wifi_ssid().c_str() : "n/a")),
            (id(wifi_id).is_connected() ? id(wifi_id).wifi_rssi() : 0)
          );
          l += lh;

          it.printf(0, l, f, TextAlign::TOP_LEFT, "Battery: %.02fV", id(battery).state);
          l += lh;

          for (int x=-1*random(10); x<=w+20; x+=24) {
            it.printf(x, h+6, id(mdi), TextAlign::BOTTOM_LEFT, "%s", city[random(cityLen)]);
          }

        } else if (id(face) == FACE_HUGE_WEATHER_ICON) {

          if (id(weather_temp_max) != -1000.0 && epochTime <= weatherExpiryTime) {
            it.printf(0, 0, id(date_font), TextAlign::TOP_LEFT, "%.0fÂ°", id(weather_temp_max));
          }


          for (int x=0; x<=3 && epochTime >= id(weather_times)[x-1]; ++x) {
            if (epochTime <= id(weather_times)[x]) {
              it.printf(w/2, h/2 - 25, id(mdi_weather_huge), TextAlign::CENTER, "%s", weatherIcons[id(weather_codes)[x]]);
              it.printf(w/2, h, id(mdi_weather_big), TextAlign::BOTTOM_CENTER, "%s%s%s",
                x < 1 && epochTime <= id(weather_times)[1] ? weatherIcons[id(weather_codes)[1]] : "",
                x < 2 && epochTime <= id(weather_times)[2] ? weatherIcons[id(weather_codes)[2]] : "",
                x < 3 && epochTime <= id(weather_times)[3] ? weatherIcons[id(weather_codes)[3]] : ""
              );
            }
          }

          it.printf(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, "%s", wifiIcon);

        } else if (id(face) == FACE_QUAD_WEATHER_ICONS) {

          const auto f = id(mdi_weather_very_big);

          if (epochTime <= id(weather_times)[0]) {
            it.print(0, 0, f, TextAlign::TOP_LEFT, weatherIcons[id(weather_codes)[0]]);
          }
          if (epochTime <= id(weather_times)[1]) {
            it.print(w, 0, f, TextAlign::TOP_RIGHT, weatherIcons[id(weather_codes)[1]]);
          }
          if (id(weather_temp_max) != -1000.0 && epochTime <= weatherExpiryTime) {
            it.printf(w/2, h/2, id(date_font), TextAlign::CENTER, "%.0fÂ°", id(weather_temp_max));
          }
          if (epochTime <= id(weather_times)[2]) {
            it.print(0, h, f, TextAlign::BOTTOM_LEFT, weatherIcons[id(weather_codes)[2]]);
          }
          if (epochTime <= id(weather_times)[3]) {
            it.print(w, h, f, TextAlign::BOTTOM_RIGHT, weatherIcons[id(weather_codes)[3]]);
          }

          it.print(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, wifiIcon);
        }

      } else if (id(mode) == $MODE_TIMERS) {

        it.printf(0, 0, id(mdi_small), TextAlign::TOP_LEFT, mdiTimerOutline);

        int l = 0;
        const int lh = 32;
        const auto f = id(date_font);

        it.printf(w/2, l, f, TextAlign::TOP_CENTER, "%d:%02d", now.hour, now.minute);
        l += lh * 1.8;

        const char *abcde = "ABCDE";

        for (int i=id(active_timer)+1; i<id(active_timer)+6; ++i) {
          int x = i % 5;
          if (id(timers)[x] != 0) {
            // Timer label:
            it.printf(0, l, id(small_font), TextAlign::CENTER_LEFT, "%c", abcde[x]);

            // Main timer:
            const int timer = epochTime - id(timers)[x];
            const int timer_hrs = timer / (60*60);
            const int timer_min = (timer / 60) % 60;
            if (timer_hrs < 100) {
              it.printf(w/2+8, l, f, TextAlign::CENTER_RIGHT,
                "%2d:%02d",
                timer_hrs,
                timer_min
              );
            }

            // Split timer:
            int y = (x + 1) % 5; // Previous timer index
            if (id(timers)[y] != 0 && id(timers)[y] >= id(timers)[x]) {
              const int split = id(timers)[y] - id(timers)[x];
              const int split_hrs = split / (60*60);
              const int split_min = (split / 60) % 60;
              if (split_hrs < 100) {
                it.printf(w, l, f, TextAlign::CENTER_RIGHT,
                  "%2d:%02d",
                  split_hrs,
                  split_min
                );
              }
            }

            l += lh;
          }
        }

        // Wifi status //
        it.printf(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, "%s", wifiIcon);

      } else if (id(mode) == $MODE_MENU) {

        it.print(w + 8, 0 - 5, id(mdi_small), TextAlign::TOP_RIGHT, "$mdiArrowUpThin");
        it.print(w + 8, h + 5, id(mdi_small), TextAlign::BOTTOM_RIGHT, "$mdiArrowDownThin");
        it.print(0 - 2, h + 4, id(mdi_small), TextAlign::BOTTOM_LEFT, "$mdiCheckCircleOutline");
        it.print(0 - 5, 0 - 3, id(mdi_small), TextAlign::TOP_LEFT, "$mdiArrowLeftTop");
        it.menu(30, 10, id(menu), w, h - 10);

      } else if (id(mode) >= 1000) {
        id(mode) = id(mode) - 1000;
        it.print(w/2, h/2, id(date_font), TextAlign::BOTTOM_CENTER, "DON'T");
        it.print(w/2, h/2, id(date_font), TextAlign::TOP_CENTER, "PANIC");

      } else if (id(mode) == $MODE_QR) {
        auto qr = id(qr_vcard);
        const char *qrModeIcon = mdiAccountBox;

        if (id(qr_mode) == 1) {
          qr = id(qr_website);
          qrModeIcon = mdiWebBox;
        } else if (id(qr_mode) == 2) {
          qr = id(qr_rss);
          qrModeIcon = mdiRssBox;
        }

        const int offset = 18;
        const auto size = qr->get_size();
        const int scale = int(float(w - offset) / float(size));
        const auto x = (w / 2) - ((size * scale) / 2);
        const auto y = ((h - offset) / 2) - ((size * scale) / 2) + offset;

        it.print(0, 0, id(mdi_small), TextAlign::TOP_LEFT, qrModeIcon);
        it.printf(w/2, -2, id(small_font), TextAlign::TOP_CENTER, "%d:%02d", now.hour, now.minute);
        it.printf(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, "%s", wifiIcon);
        it.qr_code(x, y, qr, Color(255,255,255), scale);
      }

graphical_display_menu:
  # https://esphome.io/components/display_menu/
  id: menu
  active: true
  mode: rotary
  font: small_font
  items:
    - type: switch
      text: Alarm A
      switch: alarm_a_enable
    - type: number
      text: "              "
      number: alarm_a_hour
      value_lambda: return (String(int(id(alarm_a_hour).state)) + ":00").c_str();
      on_value:
        then:
          lambda: id(alarm_a_enable).turn_on();

    - type: switch
      text: Alarm B
      switch: alarm_b_enable
    - type: number
      text: "              "
      number: alarm_b_hour
      value_lambda: return (String(int(id(alarm_b_hour).state)) + ":00").c_str();
      on_value:
        then:
          lambda: id(alarm_b_enable).turn_on();

    - type: switch
      text: Power save
      switch: power_saving_mode

binary_sensor:
  # https://esphome.io/components/binary_sensor
  # https://esphome.io/components/binary_sensor/gpio

  ## Left Top ##

  - id: power_on_button
    pin:
      number: $BUTTON_LEFT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            id(keep_awake) = true;
            id(sleep_timeout) = 0;
            if (id(alarm_buzzing)) {
              id(alarm_buzzing) = false;
              id(buzzer).turn_off();
            } else if (id(mode) != $MODE_FACES) {
              id(mode) = $MODE_FACES;
              id(menu).show_main();
            } else if (id(wifi_id).is_disabled()) {
              id(power_saving_mode).turn_off();
              id(updating_weather) = true;
              id(wifi_id).enable();
            } else {
              id(epaper).do_full_update();
            }
            id(epaper).update();

  - id: full_epaper_refresh_button
    pin:
      number: $BUTTON_LEFT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 3s
    on_press:
      - lambda: |-
          id(keep_awake) = true;
          id(sleep_timeout) = 0;
          id(epaper).do_full_update();
          id(epaper).update();

  - id: power_saving_mode_button
    pin:
      number: $BUTTON_LEFT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 5s
    on_press:
      - lambda: |-
          if (id(mode) == $MODE_FACES) {
            id(power_saving_mode).turn_on();
            id(keep_awake) = false;
            id(updating_weather) = false;
            id(wifi_id).disable();
            id(epaper).update();
            id(go_to_sleep).execute();
          }

  ## Left Bottom ##

  - id: timer_button
    pin:
      number: $BUTTON_LEFT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            id(keep_awake) = true;
            id(sleep_timeout) = 0;
            if (id(mode) == $MODE_MENU) {
              id(menu).enter();
            } else if (id(mode) == $MODE_TIMERS) {
              id(active_timer) = (id(active_timer) + 1) % 5;
              id(timers)[id(active_timer)] = id(ntp).utcnow().timestamp;
            } else {
              id(mode) = $MODE_TIMERS;
            }
            id(epaper).update();

  - id: cancel_active_timer_button
    pin:
      number: $BUTTON_LEFT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 3s
    on_press:
      - lambda: |-
          id(keep_awake) = true;
          id(sleep_timeout) = 0;
          if (id(mode) == $MODE_TIMERS) {
            id(mode) = $MODE_TIMERS;
            id(timers)[id(active_timer)] = 0;
            if (id(active_timer) != 0) {
              id(active_timer) -= 1;
            }
            id(epaper).update();
          } else if (id(mode) == $MODE_MENU) {
            id(menu).show_main();
          }

  - id: clear_all_timers_button
    pin:
      number: $BUTTON_LEFT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 5s
    on_press:
      - lambda: |-
          id(keep_awake) = true;
          id(sleep_timeout) = 0;
          if (id(mode) == $MODE_TIMERS) {
            id(mode) = $MODE_TIMERS;
            id(active_timer) = 0;
            id(timers)[0] = 0;
            id(timers)[1] = 0;
            id(timers)[2] = 0;
            id(timers)[3] = 0;
            id(timers)[4] = 0;
            id(epaper).update();
          }

  ## Right Top ##

  - id: face_cycle_button
    pin:
      number: $BUTTON_RIGHT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            id(keep_awake) = true;
            id(sleep_timeout) = 0;
            if (id(mode) == $MODE_MENU) {
              id(menu).up();
            } else if (id(mode) == $MODE_FACES) {
              id(face) = (id(face) + 1) % $FACE_COUNT;
            } else if (id(mode) == $MODE_QR) {
              id(qr_mode) = (id(qr_mode) + 1) % 3;
            } else {
              id(mode) = $MODE_FACES;
            }
            id(epaper).update();

  - id: qr_codes_mode_button
    pin:
      number: $BUTTON_RIGHT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 3s
    on_press:
      - lambda: |-
          id(keep_awake) = true;
          id(sleep_timeout) = 0;
          if (id(mode) == $MODE_FACES) {
            id(mode) = $MODE_QR;
            id(epaper).update();
          } else {
            id(mode) = $MODE_FACES;
          }

  ## Right Bottom ##

  - id: menu_mode_button
    pin:
      number: $BUTTON_RIGHT_BOTTOM_PIN
      allow_other_uses: false
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            id(keep_awake) = true;
            id(sleep_timeout) = 0;
            if (id(mode) == $MODE_MENU) {
              id(menu).down();
            } else {
              id(mode) = $MODE_MENU;
            }
            id(epaper).update();

  ## Charging ##

  - id: is_charging
    pin:
      # number: $CHRG_STATUS_PIN # Does not seem to work
      number: $USB_DET_PIN
      # inverted: true
    platform: gpio
    on_state:
      component.update: epaper

wifi:
  # https://esphome.io/components/wifi.html
  # https://esphome.io/components/wifi.html#connecting-to-multiple-networks
  id: wifi_id
  power_save_mode: HIGH
  enable_on_boot: false
  ssid: $WIFI_SSID
  password: $WIFI_PASSWORD
  fast_connect: true
  reboot_timeout: 0s
  on_connect:
    - delay: 100ms
    - component.update: epaper
    - component.update: ntp
    - script.execute: update_weather

improv_serial:
  # https://esphome.io/components/improv_serial.html
  # This component allows wifi to be set by https://web.esphome.io/

script:
  # https://esphome.io/components/script.html

  - id: update_weather
    mode: single
    then:
      # - lambda: ESP_LOGE("watchy", "Weather HTTP request.");
      # TODO: Add if-condition to test if $WEATHER_KEY has been set in secrets.yaml
      - http_request.get:
          # https://esphome.io/components/http_request.html#http-request-get-action
          # https://openweathermap.org/forecast5
          url: http://api.openweathermap.org/data/2.5/forecast?cnt=4&id=$WEATHER_CITY_ID&units=$UNITS&lang=$LANG&appid=$WEATHER_KEY
          headers:
            Content-Type: application/json
          capture_response: true
          max_response_buffer_size: 3kB
          on_response:
            then:
              - lambda: |-
                  // ESP_LOGE("watchy", "Weather status %d %ums.", status_code, duration_ms);

                  json::parse_json(body, [](JsonObject root) -> bool {
                    float tMin = 1000.0;
                    float tMax = -1000.0;

                    for (int x=0; x<=3; ++x) {
                      // ESP_LOGE("watchy", "Weather code %d @ %d", root["list"][x]["weather"][0]["id"], root["list"][x]["dt"]);
                      id(weather_times)[x] = int(root["list"][x]["dt"]) + 90 * 60; // Add 90min (50%) to expiry time
                      id(weather_codes)[x] = weatherCode(root["list"][x]["weather"][0]["id"], root["list"][x]["sys"]["pod"]);
                      tMin = min(tMin, float(root["list"][x]["main"]["temp_min"]));
                      tMax = max(tMax, float(root["list"][x]["main"]["temp_max"]));
                    }

                    id(weather_temp_min) = tMin;
                    id(weather_temp_max) = tMax;

                    return true;
                  });

                  id(updating_weather) = false;

                  if (id(mode) == $MODE_FACES) {
                    id(epaper).do_full_update();
                  }

              - delay: 10ms ## Adding a delay because epaper updates are glitchy after weather response
              - component.update: epaper
              - delay: 100ms
              - script.execute: go_to_sleep

  - id: go_to_sleep
    mode: restart
    then:
      - if:
          condition:
            lambda: return id(keep_awake);
          then:
            if:
              condition:
                lambda: return id(sleep_timeout) > 5;
              then:
                - lambda: |-
                    id(keep_awake) = false;
                    id(alarm_buzzing) = false;
                    if (id(mode) == $MODE_MENU) {
                      id(mode) = $MODE_FACES;
                    }
                - wifi.disable:
                - switch.turn_off: buzzer
                - component.update: epaper
                - deep_sleep.enter: &deep_sleep_duration
                    sleep_duration: !lambda |-
                      const auto now = id(ntp).now();
                      if (id(power_saving_mode).state) {
                        return ((60 - now.minute) * 60 - now.second) * 1000;
                      } else {
                        // 1 minute sleep:
                        return 60000;
                        // 10 minute sleep:
                        // return ((10 - (now.minute % 10)) * 60 - now.second) * 1000;
                      }
          else:
            if:
              condition:
                lambda: return !id(updating_weather) || id(sleep_timeout) > 3;
              then:
                - switch.turn_off: buzzer
                - deep_sleep.enter:
                    <<: *deep_sleep_duration

time:
  # https://esphome.io/components/time/index.html
  # https://esphome.io/components/time/sntp

  - id: ntp
    platform: sntp
    timezone: $TIME_ZONE
    servers:
      - $SNTP_SERVER_1
      - $SNTP_SERVER_2
      - $SNTP_SERVER_3
    on_time_sync:
      # https://esphome.io/components/time/index.html#time-on-time-sync
      if:
        condition:
          - wifi.connected:
          - lambda: "return id(ntp).now().is_valid();"
        then:
          # - pcf8563.write_time: # Only for Watchy v2
          - component.update: epaper
    on_time:
      # https://esphome.io/components/time/index.html#time-on-time
      - seconds: 0
        then:
          - lambda: |-
              id(sleep_timeout) += 1;
              id(epaper).update();
              id(go_to_sleep).execute();
      - seconds: /5
        then:
          - lambda: |-
              // Alarm will buzz for 2 minutes if not silenced:
              if (id(alarm_buzzing) && id(sleep_timeout) <= 2) {
                id(buzzer).turn_on();
              }
          - delay: 1s
          - switch.turn_off: buzzer

  ## https://esphome.io/components/time/pcf8563.html
  # - platform: pcf8563 # Only for Watchy v2
  #   id: pcf
  #   update_interval: never
  #   address: 0x51

deep_sleep:
  # https://esphome.io/components/deep_sleep.html
  wakeup_pin_mode: INVERT_WAKEUP
  wakeup_pin:
    number: $BUTTON_LEFT_TOP_PIN
    inverted: $BUTTON_PIN_INVERTED
    allow_other_uses: true

globals:
  # https://esphome.io/components/globals.html
  - id: sleep_timeout
    type: int
    initial_value: "0"
  - id: keep_awake
    type: boolean
    initial_value: "false"
  - id: updating_weather
    type: boolean
    initial_value: "false"
  - id: chime
    type: boolean
    initial_value: "false"
  - id: alarm_buzzing
    type: boolean
    initial_value: "false"
  ## Persistent ##
  # These following variables will be preserved (saved in flash memory) even after the ESP32 reboots
  - id: face
    type: int
    restore_value: yes
    initial_value: "0"
  - id: mode
    type: int
    restore_value: yes
    initial_value: "0"
  - id: qr_mode
    type: int
    restore_value: yes
    initial_value: "0"
  - id: weather_codes
    type: int[4]
    restore_value: yes
    initial_value: "{800, 210, 502, 1800}"
  - id: weather_times
    type: int[4]
    restore_value: yes
    initial_value: "{2019646800, 2019646800, 2019646800, 2019646800}"
  - id: weather_temp_min
    type: float
    restore_value: yes
    initial_value: "14"
  - id: weather_temp_max
    type: float
    restore_value: yes
    initial_value: "25"
  - id: active_timer
    type: int
    restore_value: yes
    initial_value: "0"
  - id: timers
    type: int[5]
    restore_value: yes

font:
  # https://esphome.io/components/display/fonts.html

  # https://freefonts.co/fonts/futura-bold

  - id: small_font
    file: "fonts/Futura Bold/Futura Bold.otf"
    size: 16
    glyphs: "().:Â°'-/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz"

  - id: date_font
    file: "fonts/Futura Bold/Futura Bold.otf"
    size: 28
    glyphs: ":Â°'-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz"

  - id: time_font
    file: "fonts/Futura Bold/Futura Bold.otf"
    size: 64
    glyphs: ":0123456789-"

  # https://github.com/Templarian/MaterialDesign-Webfont/tree/master/fonts
  # These icon codes are defined in ./mdi.yaml
  # mdi.yaml is regenerated/updated by running `node generate-mdi.js`

  - id: mdi_small
    file: fonts/mdi/fonts/materialdesignicons-webfont.woff
    size: 26
    glyphs:
      # See ./mdi.yaml
      - "$mdiAccountBox"
      - "$mdiAlarmCheck"
      - "$mdiArrowDownThin"
      - "$mdiArrowLeftTop"
      - "$mdiArrowUpThin"
      - "$mdiBatteryChargingHigh"
      - "$mdiBatteryHigh"
      - "$mdiBatteryLow"
      - "$mdiBatteryMedium"
      - "$mdiBatteryOutline"
      - "$mdiBatteryRemoveOutline"
      - "$mdiBellOutline"
      - "$mdiBellRingOutline"
      - "$mdiCheckCircleOutline"
      - "$mdiEmoticonHappyOutline"
      - "$mdiHomeAssistant"
      - "$mdiRssBox"
      - "$mdiSleep"
      - "$mdiTimerOutline"
      - "$mdiWebBox"
      - "$mdiWifi"
      - "$mdiWifiAlert"
      - "$mdiWifiOff"

  - &mdi_weather
    id: mdi_weather
    file: fonts/mdi/fonts/materialdesignicons-webfont.woff
    size: 36
    glyphs:
      # See ./mdi.yaml
      - "$mdiAlert"
      - "$mdiWeatherCloudy"
      - "$mdiWeatherCloudyAlert"
      - "$mdiWeatherCloudyArrowRight"
      - "$mdiWeatherDust"
      - "$mdiWeatherFog"
      - "$mdiWeatherHail"
      - "$mdiWeatherHazy"
      - "$mdiWeatherHurricane"
      - "$mdiWeatherLightning"
      - "$mdiWeatherLightningRainy"
      - "$mdiWeatherNight"
      - "$mdiWeatherNightPartlyCloudy"
      - "$mdiWeatherPartlyCloudy"
      - "$mdiWeatherPartlyLightning"
      - "$mdiWeatherPartlyRainy"
      - "$mdiWeatherPartlySnowy"
      - "$mdiWeatherPartlySnowyRainy"
      - "$mdiWeatherPouring"
      - "$mdiWeatherRainy"
      - "$mdiWeatherSnowy"
      - "$mdiWeatherSnowyHeavy"
      - "$mdiWeatherSnowyRainy"
      - "$mdiWeatherSunny"
      - "$mdiWeatherSunnyAlert"
      - "$mdiWeatherSunnyOff"
      - "$mdiWeatherSunset"
      - "$mdiWeatherSunsetDown"
      - "$mdiWeatherSunsetUp"
      - "$mdiWeatherTornado"
      - "$mdiWeatherWindy"
      - "$mdiWeatherWindyVariant"

  - <<: *mdi_weather
    id: mdi_weather_big
    size: 64

  - <<: *mdi_weather
    id: mdi_weather_very_big
    size: 96

  - <<: *mdi_weather
    id: mdi_weather_huge
    size: 146

  - <<: *mdi_weather
    id: mdi
    glyphs:
      - "$mdiAirballoon"
      - "$mdiBee"
      - "$mdiBicycle"
      - "$mdiBird"
      - "$mdiCakeVariantOutline"
      - "$mdiCastle"
      - "$mdiCity"
      - "$mdiCityVariant"
      - "$mdiClover"
      - "$mdiCodeBraces"
      - "$mdiCreationOutline"
      - "$mdiDeathStarVariant"
      - "$mdiDebugStepOver"
      - "$mdiDonkey"
      - "$mdiEarth"
      - "$mdiElephant"
      - "$mdiEmoticonHappyOutline"
      - "$mdiFerry"
      - "$mdiForest"
      - "$mdiGoogleDownasaur"
      - "$mdiHalloween"
      - "$mdiHeart"
      - "$mdiHelicopter"
      - "$mdiHospitalBuilding"
      - "$mdiHumanMaleBoard"
      - "$mdiHumanMaleChild"
      - "$mdiLinkBoxVariant"
      - "$mdiOfficeBuilding"
      - "$mdiPartyPopper"
      - "$mdiPeace"
      - "$mdiPineTree"
      - "$mdiPlusThick"
      - "$mdiRocketLaunch"
      - "$mdiSatelliteVariant"
      - "$mdiSchool"
      - "$mdiSpaceInvaders"
      - "$mdiSpaceStation"
      - "$mdiStarOutline"
      - "$mdiStarShootingOutline"
      - "$mdiTeddyBear"
      - "$mdiUfoOutline"
      - "$mdiVote"
      - "$mdiWater"

esp32:
  # https://esphome.io/components/esp32.html
  board: esp32-s3-devkitc-1
  flash_size: 8MB
  # https://raw.githubusercontent.com/espressif/arduino-esp32/master/tools/partitions/default_8MB.csv
  partitions: default_8MB.csv
  variant: esp32s3

sensor:
  # https://esphome.io/components/sensor/index.html
  # https://esphome.io/components/sensor/adc.html
  - platform: adc
    id: battery
    attenuation: auto
    pin: $BATTERY_ADC_PIN
    update_interval: never
    filters:
      - multiply: $BATTERY_VOLTAGE_DIVIDER

switch:
  # https://esphome.io/components/switch/index.html
  # https://esphome.io/components/switch/gpio.html
  # https://esphome.io/components/switch/template.html

  - platform: gpio
    id: buzzer
    pin: $VIB_MOTOR_PIN

  - &alarm_enable
    platform: template
    id: alarm_a_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - <<: *alarm_enable
    id: alarm_b_enable

  - platform: template
    id: power_saving_mode
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

number:
  # https://esphome.io/components/number/template.html
  - &alarm_hour
    platform: template
    id: alarm_a_hour
    optimistic: true
    restore_value: true
    min_value: 0
    initial_value: 12
    max_value: 23
    step: 1

  - <<: *alarm_hour
    id: alarm_b_hour

i2c:
  # https://esphome.io/components/i2c.html
  scan: false
  sda: $I2C_SDA_PIN
  scl: $I2C_SCL_PIN

spi:
  # https://esphome.io/components/spi.html
  # SPI is used by the ePaper display
  # SPI_SS_PIN ??
  mosi_pin: $SPI_MOSI_PIN
  miso_pin: $SPI_MISO_PIN
  clk_pin: $SPI_SCK_PIN

ota:
  # https://esphome.io/components/ota/
  password: $OTA_PASSWORD
  platform: esphome

http_request:
  # https://esphome.io/components/http_request.html#
  id: http_request_data
  verify_ssl: false

qr_code:
  # https://esphome.io/components/display/index.html

  - id: qr_vcard
    ecc: LOW
    value: $QR_VCARD

  - id: qr_website
    ecc: LOW
    value: $QR_WEBSITE_URL

  - id: qr_rss
    ecc: LOW
    value: $QR_RSS_URL

external_components:
  # https://esphome.io/components/external_components.html
  # This project used a slightly modified module forked from the main ESPHome project.
  # The minor customisations for Watchy are:
  #  Prevent a full ePaper refresh on ESP32 boot which is not the desired behaviour for a low-power watch.
  #   https://github.com/multipolygon/esphome/commit/6407a74ff9855d515cb16fef67f90c748f9800ea
  #  Add a pubic `do_full_update()` method to trigger the full-refresh only at certain times of day - a full update clears away ghost pixels.
  #   https://github.com/multipolygon/esphome/commit/ecf116058cc4b20007126f9099f4b07f4d46b9dd
  - components: [waveshare_epaper]
    source:
      # type: local
      # path: ../esphome/esphome/components
      type: git
      url: https://github.com/multipolygon/esphome
      ref: dev
