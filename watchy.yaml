## ESPHome for Watchy ##
# https://watchy.sqfmi.com/docs/hardware

substitutions:
  # https://esphome.io/guides/configuration-types.html#substitutions
  <<: !include config.yaml
  <<: !include pins-v3.yaml
  <<: !include mdi.yaml
  ID: "1"
  NAME: watchy-v$VERSION-id$ID
  WAKE_TIME: "5"
  FACE_COUNT: "9"
  MODE_FACES: "0"
  MODE_TIMERS: "1"
  MODE_MENU: "2"
  MODE_QR: "3"
  MODE_DP: "4"
  MODE_WUN: "5"
  MODE_AGENDA: "6"
  AGENDA_REMINDER_1: "60" # min
  AGENDA_REMINDER_2: "10" # min
  AGENDA_JSON_BYTES: "1024"

logger:
  # https://esphome.io/components/logger.html#log-levels
  level: NONE

esphome:
  # https://esphome.io/components/esphome.html#esphome-core-configuration
  name: $NAME
  includes:
    - mdi.h
    - icons.h
    - util.h
  on_boot:
    then:
      - delay: 1ms
      # - pcf8563.read_time: # Only for Watchy v2
      - component.update: battery
      - lambda: |-
          const auto now = id(ntp).now();
          const auto utcnow = id(ntp).utcnow();

          randomSeed(utcnow.timestamp + id(weather_times)[0]);

          if (id(mode) == $MODE_MENU) {
            id(mode) = $MODE_FACES;
          }

          if (
            // ESP_SLEEP_WAKEUP_EXT0 is button-press wake-up:
            esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_EXT0 
            // ESP_SLEEP_WAKEUP_UNDEFINED is after flash:
            || esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_UNDEFINED && id(is_charging).state
          ) {
            id(sleep_timeout) = $WAKE_TIME;
            id(power_saving_mode).turn_off();
            if (id(ntp).utcnow().timestamp >= id(weather_times)[0]) {
              id(request_weather).turn_on();
            }
            id(wi_fi).enable();
            id(buzzer).turn_on();
          }

          if (now.hour == 0 && now.minute == 0) {
            // Reset daily agenda:
            id(agenda) = "[]"; // empty JSON array
            id(next_agenda_start) = -1;
            id(next_agenda_title) = "";
          }

          id(alarms).execute();

          if (!id(power_saving_mode).state) {
            if (utcnow.hour % 3 == 0 && utcnow.minute == 0) {
              // openweathermap.org publishes a new forecast every 3 hours relative to UTC:
              id(request_weather).turn_on();
              id(sleep_timeout) = 2; // Allow 2 minutes to update weather
              id(wi_fi).enable();
            }

            if (id(mode) == $MODE_FACES
                && id(sleep_timeout) == 0
                && !id(chime)
                && !id(alarm_buzzing)
            ) {
              auto r = random(100);
              if (0 == r) {
                id(mode) = $MODE_DP;
              } else if (1 == r) {
                id(mode) = $MODE_WUN;
              }
            }
          }

          id(epaper).update();
          id(buzzer).turn_off();
          id(conditional_sleep).execute();
          id(alarm_buzzer).execute();
      - if:
          condition:
            lambda: return id(chime) && !id(alarm_buzzing);
          then:
            - switch.turn_on: buzzer
            - delay: 250ms
            - switch.turn_off: buzzer

display:
  # Configuration for the display
  # https://esphome.io/components/display/
  # https://esphome.io/components/display/waveshare_epaper.html
  # https://www.good-display.com/product/206.html
  # https://www.e-paper-display.com/products_detail/productId=455.html
  - id: epaper
    platform: waveshare_epaper
    model: 1.54inv2
    cs_pin: $DISPLAY_CS_PIN
    dc_pin: $DISPLAY_DC_PIN
    reset_pin: $DISPLAY_RES_PIN
    busy_pin: $DISPLAY_BUSY_PIN
    update_interval: never
    # Problem: full_update_every does not work as expected because esphome code will do a full update on every boot up.
    # Solution: Edited `waveshare_epaper.h` and initialise to 1 instead of 0: `uint32_t at_update_{1};`
    # See: `external_components` near the bottom.
    full_update_every: 1000
    # Duration for the display reset operation. Defaults to 200ms. Setting this value to 2ms may resolve issues with newer e-Paper Driver modules (e.g. Rev 2.1).
    reset_duration: 2ms # ?????
    lambda: |-
      const auto w = it.get_width();
      const auto h = it.get_height();
      const auto BLACK = Color::WHITE;
      const auto WHITE = Color::BLACK;

      const auto epochTime = id(ntp).timestamp_now();
      const auto realNow = id(ntp).now();

      // By default, the watch will update once a minute and shows accurate (NTP) time.
      // However, that can use more power than is neccessary and, as a matter of opinion,
      // a slightly fast watch is a good thing and a pre-rounded, slow-update watch is more calming.
      // Who doesn't do some time-rounding in one's head anyway? If its 12:43 you think 12:45.
      // When someone asks you the time and its 12:42 you say "12:45" or "quarter to 1".
      // When the watch is in power-saving mode or set to 5 or 10 minute update intervals,
      // the epaper display updates will only occur every 5 or 10 minutes.
      // So this code here will set `now` to a fast-forwarded time and then update the epaper.
      // The result is a watch that is up to 5/10 minutes fast, but never behind.
      const int sleepTimeSeconds = id(sleep_timeout) > 0 ? 0 :
        calcSleepTimeSeconds(
          id(power_saving_mode).state,
          id(clock_interval_minutes).state,
          realNow
        );
      const auto now = sleepTimeSeconds == 0 ?
        realNow :
        // https://esphome.io/api/structesphome_1_1_e_s_p_time#a15c3bfe41e5c836695602e95225e5541
        esphome::ESPTime::from_epoch_local(epochTime + sleepTimeSeconds);
      const int tnow = now.hour * 60 + now.minute;

      const auto weatherExpiryTime = id(weather_times)[3];

      const auto m = now.month;
      const auto d = now.day_of_month;
      const auto md = m * 100 + d;
      const auto FRIDAY = 6;

      const char *alertIcon =
        id(agenda_alarm_time) > 0 ? mdiBellBadgeOutline :
        id(alarm_buzzing) ? mdiBellRingOutline :
        id(chime) ? mdiBellOutline :
        "";

      const char *wifiIcon = id(sleep_timeout) > 0 ?
        (id(wi_fi).is_disabled() ? mdiEmoticonHappyOutline : (id(wi_fi).is_connected() ? mdiWifi  : mdiWifiOff)) :
        (id(power_saving_mode).state ? mdiSleep : "");

      const char *batteryIcon = id(is_charging).state ? mdiUsbPort : (
        !id(battery).has_state() ? mdiBatteryRemoveOutline : (
          id(battery).state > $BATTERY_FULL ? mdiBatteryHigh : (
            id(battery).state > $BATTERY_HIGH ? mdiBatteryMedium : (
              id(battery).state > $BATTERY_LOW ? mdiBatteryLow :
                mdiBatteryOutline
            )
          )
        )
      );

      char leftStatusIcons[20];
      snprintf(leftStatusIcons, 20, "%s%s%s",
        alertIcon,
        id(request_weather).state ? mdiCloudDownloadOutline : "",
        wifiIcon
      );

      char rightStatusIcons[20];
      snprintf(rightStatusIcons, 20, "%s%s%s",
        batteryIcon,
        id(alarm_a_enable).state || id(alarm_b_enable).state ? mdiAlarmCheck : "",
        id(next_agenda_start) > 0 ? mdiCalendarClock : ""
      );

      const char *significantDateIcon = "";
      if (
        m == $BIRTHMONTH && d == $BIRTHDAY ||
        m == $BIRTHMONTH1 && d == $BIRTHDAY1 ||
        m == $BIRTHMONTH2 && d == $BIRTHDAY2
      ) {
        significantDateIcon = mdiCakeVariantOutline;
      } else if (significantDatesIcons.find(md) != significantDatesIcons.end()) {
        significantDateIcon = significantDatesIcons[md];
      } else if (now.day_of_year == 256) {
        significantDateIcon = mdiCodeBraces;
      } else if (now.day_of_week == FRIDAY && d == 13) {
        significantDateIcon = mdiClover;
      }

      if (id(mode) == $MODE_FACES) {
        const int FACE_DIGITAL_24 = 0;
        const int FACE_DIGITAL_12 = 1;
        const int FACE_HANDS_ARABIC = 2;
        const int FACE_HANDS_ARABIC_SMALL = 3;
        const int FACE_HANDS_ROMAN = 4;
        const int FACE_HANDS_ROMAN_SMALL = 5;
        const int FACE_HUGE_WEATHER_ICON = 6;
        const int FACE_QUAD_WEATHER_ICONS = 7;
        const int FACE_INFO_DEBUG = 8;

        if (id(face) == FACE_DIGITAL_24 || id(face) == FACE_DIGITAL_12) {

          // Date //
          it.strftime(w/2, 0, id(date_font), TextAlign::TOP_CENTER, "%a %d %b", now);

          // Time //
          auto hour = now.hour;
          if (id(face) == FACE_DIGITAL_12) {
            hour = hour % 12;
            if (hour == 0) { hour = 12; }
            it.print(w-5, h/2+46, id(small_font), TextAlign::CENTER_RIGHT, now.hour < 12 ? "AM" : "PM");
          }
          if (hour <= 9) {
            it.printf(5, h/2, id(mdi), TextAlign::CENTER_LEFT, "%s", significantDateIcon);
          }
          it.printf(w/2-10, h/2, id(time_font), TextAlign::CENTER_RIGHT, "%d", hour);
          it.print(w/2, h/2-5, id(time_font), TextAlign::CENTER, ":");
          it.printf(w/2+10, h/2, id(time_font), TextAlign::CENTER_LEFT, "%02d", now.minute);

          // Weather //
          if (id(weather_temp_max) != -1000.0 && epochTime <= weatherExpiryTime) {
            it.printf(0, h, id(date_font), TextAlign::BOTTOM_LEFT, "%.0f°", id(weather_temp_max));
          }
          it.printf(w, h, id(mdi_weather), TextAlign::BOTTOM_RIGHT, "%s%s%s%s",
            epochTime <= id(weather_times)[0] ? weatherIcons[id(weather_codes)[0]] : "",
            epochTime <= id(weather_times)[1] ? weatherIcons[id(weather_codes)[1]] : "",
            epochTime <= id(weather_times)[2] ? weatherIcons[id(weather_codes)[2]] : "",
            epochTime <= id(weather_times)[3] ? weatherIcons[id(weather_codes)[3]] : ""
          );

          // Status Icons //
          it.printf(w/2 - 26/2, h/2+46, id(mdi_small), TextAlign::CENTER_RIGHT, "%s", leftStatusIcons);
          it.printf(w/2 - 26/2, h/2+46, id(mdi_small), TextAlign::CENTER_LEFT, "%s", rightStatusIcons);

          // Active Timer //
          if (id(timers)[id(active_timer)] != 0) {
            int activeTimer = epochTime - id(timers)[id(active_timer)];
            if (activeTimer < 48 * 60 * 60) { // Limit to 48 hours
              it.printf(w/2, h/2-46, id(small_font), TextAlign::CENTER,
                "%dh %02dm",
                (activeTimer) / (60*60),
                (activeTimer / 60) % 60
              );
            } else {
              it.printf(w/2, h/2-46, id(small_font), TextAlign::CENTER,
                "%dd %dh %02dm",
                activeTimer / (24*60*60),
                (activeTimer % (24*60*60)) / (60*60),
                (activeTimer / 60) % 60
              );
            }

          } else if (id(next_agenda_start) == 0) {
            it.printf(w/2, h/2-46, id(small_font), TextAlign::CENTER, "%s", id(next_agenda_title).c_str());

          } else if (id(next_agenda_start) > 0 && id(next_agenda_end) >= tnow) {
            if (id(next_agenda_start) > tnow) {
              it.printf(w/2, h/2-46, id(small_font), TextAlign::CENTER,
                "%02d:%02d %s", id(next_agenda_start) / 60, id(next_agenda_start) % 60, id(next_agenda_title).c_str()
              );
            } else {
              it.printf(w/2, h/2-46, id(small_font), TextAlign::CENTER,
                "%s %02d:%02d", id(next_agenda_title).c_str(), id(next_agenda_end) / 60, id(next_agenda_end) % 60
              );
            }

          } else {
            // https://metric-time.com/
            const auto metricTime = ((float(now.hour) * 60.0 * 60.0 + float(now.minute) * 60.0 + float(now.second)) / 86400.0) * 1000.0;
            it.printf(w/2, h/2-46, id(small_font), TextAlign::CENTER, "%.0f:%02d", floor(metricTime / 100.0), int(metricTime) % 100);
          }

        } else if (id(face) == FACE_HANDS_ARABIC || id(face) == FACE_HANDS_ARABIC_SMALL || id(face) == FACE_HANDS_ROMAN || id(face) == FACE_HANDS_ROMAN_SMALL) {

          const bool n = id(face) == FACE_HANDS_ARABIC || id(face) == FACE_HANDS_ARABIC_SMALL;
          const bool s = id(face) == FACE_HANDS_ARABIC_SMALL || id(face) == FACE_HANDS_ROMAN_SMALL;

          // Center Dot //
          it.filled_circle(w/2, w/2, 5);

          // Big Marks //
          const auto bigFont = s ? id(small_font) : id(date_font);
          it.print(w, h/2, bigFont, TextAlign::CENTER_RIGHT, n ? "3" : "III");
          it.print(w/2, h+(s ? 0 : 6), bigFont, TextAlign::BOTTOM_CENTER, n ? "6" : "VI");
          it.print(0, h/2, bigFont, TextAlign::CENTER_LEFT, n ? "9" : "IX");
          it.print(w/2, 0-(s ? 0 : 8), bigFont, TextAlign::TOP_CENTER, n ? "12" : "XII");

          // Small Marks //
          it.print(getClkX(1), getClkY(1), id(small_font), TextAlign::CENTER, s ? "." : n ? "1" : "I");
          it.print(getClkX(2), getClkY(2), id(small_font), TextAlign::CENTER, s ? "." : n ? "2" : "II");
          it.print(getClkX(4), getClkY(4), id(small_font), TextAlign::CENTER, s ? "." : n ? "4" : "IV");
          it.print(getClkX(5), getClkY(5), id(small_font), TextAlign::CENTER, s ? "." : n ? "5" : "V");
          it.print(getClkX(7), getClkY(7), id(small_font), TextAlign::CENTER, s ? "." : n ? "7" : "VII");
          it.print(getClkX(8), getClkY(8), id(small_font), TextAlign::CENTER, s ? "." : n ? "8" : "VIII");
          it.print(getClkX(10), getClkY(10), id(small_font), TextAlign::CENTER, s ? "." : n ? "10" : "X");
          it.print(getClkX(11), getClkY(11), id(small_font), TextAlign::CENTER, s ? "." : n ? "11" : "XI");

          // Weather Temp //
          if (id(weather_temp_max) != -1000.0 && epochTime <= weatherExpiryTime) {
            it.printf(w/2, h/2 - 30, id(small_font), TextAlign::BOTTOM_CENTER, "%.0f° to %.0f°", id(weather_temp_min), id(weather_temp_max));
          }

          // Date //
          it.strftime(w/2, h/2 + 30, id(small_font), TextAlign::TOP_CENTER, "%a %d %b", now);

          // Hour Hand //
          double hr = ((now.hour % 12 + now.minute / 60.0) / 12.0 * 360.0 - 90.0) * (M_PI / 180.0);
          for (int x=-2; x<=2; ++x) {
            for (int y=-2; y<=2; ++y) {
              it.line(w/2 +x, h/2 +y, w/2.0 + w/3.5 * cos(hr) +x, h/2.0 + h/3.5 * sin(hr) +y);
            }
          }

          // Minute Hand //
          double mn = (now.minute / 60.0 * 360.0 - 90.0) * (M_PI / 180.0);
          for (int x=-1; x<=1; ++x) {
            for (int y=-1; y<=1; ++y) {
              it.line(w/2 +x, h/2 +y, w/2.0 + w/2.5 * cos(mn) +x, h/2.0 + h/2.5 * sin(mn) +y);
            }
          }

          // Weather Icons //
          int offset = 0;
          for (int x=0; x<=3; ++x) {
            if (epochTime > id(weather_times)[x]) {
              offset = x + 1;
            }
          }
          int x = rotateWeatherCode(0, now.hour) + offset;
          if (x <= 3 && epochTime <= id(weather_times)[x]) {
            it.printf(w, 0, id(mdi_weather), TextAlign::TOP_RIGHT, "%s", weatherIcons[id(weather_codes)[x]]);
          }
          x = rotateWeatherCode(1, now.hour) + offset;
          if (x <= 3 && epochTime <= id(weather_times)[x]) {
            it.printf(w, h, id(mdi_weather), TextAlign::BOTTOM_RIGHT, "%s", weatherIcons[id(weather_codes)[x]]);
          }
          x = rotateWeatherCode(2, now.hour) + offset;
          if (x <= 3 && epochTime <= id(weather_times)[x]) {
            it.printf(0, h, id(mdi_weather), TextAlign::BOTTOM_LEFT, "%s", weatherIcons[id(weather_codes)[x]]);
          }
          x = rotateWeatherCode(3, now.hour) + offset;
          if (x <= 3 && epochTime <= id(weather_times)[x]) {
            it.printf(0, 0, id(mdi_weather), TextAlign::TOP_LEFT, "%s", weatherIcons[id(weather_codes)[x]]);
          }

          // Status Icons //
          it.printf(w*1/4, h/2, id(mdi_small), TextAlign::CENTER, "%s", leftStatusIcons);
          it.printf(w*3/4, h/2, id(mdi_small), TextAlign::CENTER, "%s", rightStatusIcons);

        } else if (id(face) == FACE_INFO_DEBUG) {

          it.printf(w/2 - 22, 0, id(mdi_weather), TextAlign::TOP_RIGHT, "%s%s",
            weatherIcons[id(weather_codes)[0]],
            weatherIcons[id(weather_codes)[1]]
          );

          it.printf(w/2, 0, id(mdi), TextAlign::TOP_CENTER, "%s",
            sky[random(skyLen)]
          );

          it.printf(w/2 + 22, 0, id(mdi_weather), TextAlign::TOP_LEFT, "%s%s",
            weatherIcons[id(weather_codes)[2]],
            weatherIcons[id(weather_codes)[3]]
          );

          int l = 34;
          const int lh = 18;
          const auto f = id(small_font);

          it.print(0, l, f, TextAlign::TOP_LEFT, "$NAME");
          l += lh;

          it.strftime(0, l, f, TextAlign::TOP_LEFT , "%H:%M %a %d %b", now);
          l += lh;

          if (id(weather_temp_max) != -1000.0) {
            it.printf(0, l, f, TextAlign::TOP_LEFT, "%.0f° to %.0f° (t%+.1fh)",
              id(weather_temp_min), id(weather_temp_max),
              float(epochTime - id(weather_times)[0]) / 60.0 / 60.0
            );
          }
          l += lh;

          it.printf(0, l, f, TextAlign::TOP_LEFT,
            "Wifi: %s (%d)",
            (id(wi_fi).is_disabled() ? "off" : (id(wi_fi).is_connected() ? id(wi_fi).wifi_ssid().c_str() : "n/a")),
            (id(wi_fi).is_connected() ? id(wi_fi).wifi_rssi() : 0)
          );
          l += lh;

          it.printf(0, l, f, TextAlign::TOP_LEFT, "Battery: %.02fV", id(battery).state);
          l += lh;

          it.printf(0, l, f, TextAlign::TOP_LEFT, "Wakeup cause: %d", esp_sleep_get_wakeup_cause());
          l += lh;

          for (int x=-1*random(10); x<=w+20; x+=24) {
            it.printf(x, h+6, id(mdi), TextAlign::BOTTOM_LEFT, "%s", city[random(cityLen)]);
          }

        } else if (id(face) == FACE_HUGE_WEATHER_ICON) {

          if (id(weather_temp_max) != -1000.0 && epochTime <= weatherExpiryTime) {
            it.printf(0, 0, id(date_font), TextAlign::TOP_LEFT, "%.0f°", id(weather_temp_max));
          }


          for (int x=0; x<=3 && epochTime >= id(weather_times)[x-1]; ++x) {
            if (epochTime <= id(weather_times)[x]) {
              it.printf(w/2, h/2 - 25, id(mdi_weather_huge), TextAlign::CENTER, "%s", weatherIcons[id(weather_codes)[x]]);
              it.printf(w/2, h, id(mdi_weather_big), TextAlign::BOTTOM_CENTER, "%s%s%s",
                x < 1 && epochTime <= id(weather_times)[1] ? weatherIcons[id(weather_codes)[1]] : "",
                x < 2 && epochTime <= id(weather_times)[2] ? weatherIcons[id(weather_codes)[2]] : "",
                x < 3 && epochTime <= id(weather_times)[3] ? weatherIcons[id(weather_codes)[3]] : ""
              );
            }
          }

          it.printf(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, "%s", wifiIcon);

        } else if (id(face) == FACE_QUAD_WEATHER_ICONS) {

          const auto f = id(mdi_weather_very_big);

          if (epochTime <= id(weather_times)[0]) {
            it.print(0, 0, f, TextAlign::TOP_LEFT, weatherIcons[id(weather_codes)[0]]);
          }
          if (epochTime <= id(weather_times)[1]) {
            it.print(w, 0, f, TextAlign::TOP_RIGHT, weatherIcons[id(weather_codes)[1]]);
          }
          if (id(weather_temp_max) != -1000.0 && epochTime <= weatherExpiryTime) {
            it.printf(w/2, h/2, id(date_font), TextAlign::CENTER, "%.0f°", id(weather_temp_max));
          }
          if (epochTime <= id(weather_times)[2]) {
            it.print(0, h, f, TextAlign::BOTTOM_LEFT, weatherIcons[id(weather_codes)[2]]);
          }
          if (epochTime <= id(weather_times)[3]) {
            it.print(w, h, f, TextAlign::BOTTOM_RIGHT, weatherIcons[id(weather_codes)[3]]);
          }

          it.print(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, wifiIcon);
        }

      } else if (id(mode) == $MODE_TIMERS) {

        it.printf(0, 0, id(mdi_small), TextAlign::TOP_LEFT, mdiTimerOutline);

        int l = 0;
        const int lh = 32;
        const auto f = id(date_font);

        it.printf(w/2, l, f, TextAlign::TOP_CENTER, "%d:%02d", now.hour, now.minute);
        l += lh * 1.8;

        const char *abcde = "ABCDE";

        for (int i=id(active_timer)+1; i<id(active_timer)+6; ++i) {
          int x = i % 5;
          if (id(timers)[x] != 0) {
            // Timer label:
            it.printf(0, l, id(small_font), TextAlign::CENTER_LEFT, "%c", abcde[x]);

            // Main timer:
            const int timer = epochTime - id(timers)[x];
            const int timer_hrs = timer / (60*60);
            const int timer_min = (timer / 60) % 60;
            if (timer_hrs < 100) {
              it.printf(w/2+8, l, f, TextAlign::CENTER_RIGHT,
                "%2d:%02d",
                timer_hrs,
                timer_min
              );
            }

            // Split timer:
            int y = (x + 1) % 5; // Previous timer index
            if (id(timers)[y] != 0 && id(timers)[y] >= id(timers)[x]) {
              const int split = id(timers)[y] - id(timers)[x];
              const int split_hrs = split / (60*60);
              const int split_min = (split / 60) % 60;
              if (split_hrs < 100) {
                it.printf(w, l, f, TextAlign::CENTER_RIGHT,
                  "%2d:%02d",
                  split_hrs,
                  split_min
                );
              }
            }

            l += lh;
          }
        }

        // Wifi status //
        it.printf(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, "%s", wifiIcon);

      } else if (id(mode) == $MODE_MENU) {

        it.print(w + 8, 0 - 5, id(mdi_small), TextAlign::TOP_RIGHT, "$mdiArrowUpThin");
        it.print(w + 8, h + 8, id(mdi_small), TextAlign::BOTTOM_RIGHT, "$mdiArrowDownThin");
        it.print(0 - 2, h + 4, id(mdi_small), TextAlign::BOTTOM_LEFT, "$mdiCheckCircleOutline");
        it.print(0 - 5, 0 - 3, id(mdi_small), TextAlign::TOP_LEFT, "$mdiArrowLeftTop");
        it.menu(28, 2, id(menu), w, h-4);

      } else if (id(mode) == $MODE_DP) {
        id(mode) = $MODE_FACES;
        it.print(w/2, h/2, id(date_font), TextAlign::BOTTOM_CENTER, "DON'T");
        it.print(w/2, h/2, id(date_font), TextAlign::TOP_CENTER, "PANIC!");

      } else if (id(mode) == $MODE_WUN) {
        id(mode) = $MODE_FACES;
        it.print(0, 0, id(small_font), TextAlign::TOP_LEFT, "Wake up, Neo...");

      } else if (id(mode) == $MODE_QR) {
        auto qr = id(qr_vcard);
        const char *qrModeIcon = mdiAccountBox;

        if (id(qr_mode) == 1) {
          qr = id(qr_website);
          qrModeIcon = mdiWebBox;
        } else if (id(qr_mode) == 2) {
          qr = id(qr_rss);
          qrModeIcon = mdiRssBox;
        }

        const int offset = 18;
        const auto size = qr->get_size();
        const int scale = int(float(w - offset) / float(size));
        const auto x = (w / 2) - ((size * scale) / 2);
        const auto y = ((h - offset) / 2) - ((size * scale) / 2) + offset;

        it.print(0, 0, id(mdi_small), TextAlign::TOP_LEFT, qrModeIcon);
        it.printf(w/2, -2, id(small_font), TextAlign::TOP_CENTER, "%d:%02d", now.hour, now.minute);
        it.printf(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, "%s", wifiIcon);
        it.qr_code(x, y, qr, Color(255,255,255), scale);
      }

      if (id(mode) == $MODE_AGENDA || (id(alarm_buzzing) && id(agenda_alarm_time) != -1)) {
        if (id(mode) == $MODE_AGENDA) {
          it.printf(0, 0, id(mdi_small), TextAlign::TOP_LEFT, "%s", leftStatusIcons);
          it.printf(w, 0, id(mdi_small), TextAlign::TOP_RIGHT, "%s", rightStatusIcons);
        }

        const int m = 4;
        const int lh = 18;
        const int maxAgeMinutes = 60;

        int l = 0;
        int count = 0;
        int totalCount = 0;

        DynamicJsonDocument doc($AGENDA_JSON_BYTES);
        DeserializationError jsonErr = deserializeJson(doc, id(agenda));

        if (jsonErr == DeserializationError::Ok) {
          for (JsonArray elem : doc.as<JsonArray>()) {
            int tstart = elem[0].as<int>();
            int tend = elem[1].as<int>();
            totalCount += 1;
            if (tend >= tnow - maxAgeMinutes || tstart == 0 && tend == 1440 && now.hour <= 10) {
              count += 1;
            }
          }
        }

        const int lineLimit = h / lh - 3;
        if (totalCount <= lineLimit) {
          count = totalCount;
        }

        const int headingBoxHeight = m + lh + m + m;
        const int textBoxHeight = m + max(1, count) * lh + m + m + m;

        if (headingBoxHeight + textBoxHeight < h) {
          l = (h - headingBoxHeight - textBoxHeight) / 2;
        }

        it.filled_rectangle(0, l-4, w, headingBoxHeight + textBoxHeight + 8, WHITE);
        it.filled_rectangle(0, l, w, headingBoxHeight, BLACK);
        it.rectangle(0, l, w, headingBoxHeight + textBoxHeight);
        it.rectangle(1, l+1, w-2, headingBoxHeight + textBoxHeight - 2);

        it.strftime(m*2, l+m-1, id(small_font), WHITE, TextAlign::TOP_LEFT, "%a %d %b", now);
        it.printf(w-m*2, l+m-1, id(small_font), WHITE, BLACK, TextAlign::TOP_RIGHT, "%d:%02d", now.hour, now.minute);

        l += headingBoxHeight + m;

        if (jsonErr != DeserializationError::Ok) {
          it.print(m*2, l, id(small_font),
            // https://arduinojson.org/v6/api/misc/deserializationerror/
            jsonErr == DeserializationError::NoMemory ? "Agenda OOM" : "Agenda Err"
          );
        } else if (count == 0) {
          it.print(m*2, l, id(small_font), "No items");
        } else {
          int overLimit = 0;
          for (JsonArray elem : doc.as<JsonArray>()) {
            int tstart = elem[0].as<int>();
            int tend = elem[1].as<int>();
            String title = elem[2].as<String>();

            if (l >= h-lh) {
              // Beyond the screen height boundary
              overLimit += 1;

            } else if (tstart == 0 && tend == 1440 && (totalCount <= lineLimit || now.hour <= 10)) {
              // All-day event
              it.printf(m*2, l, id(small_font), TextAlign::TOP_LEFT, "%s", title.c_str());
              l += lh;

            } else if (tstart == 0 && tend == 1440) {
              // Skip all-day event

            } else if (totalCount <= lineLimit || tend >= tnow - maxAgeMinutes) {
              it.printf(m*2, l, id(small_font), TextAlign::TOP_LEFT, "%02d:%02d %s", tstart / 60, tstart % 60, title.c_str());

              if (id(agenda_alarm_time) == tstart) {
                it.filled_rectangle(6, l+2, 54, lh+2);
                it.printf(m*2, l, id(small_font), WHITE, BLACK, TextAlign::TOP_LEFT, "%02d:%02d", tstart / 60, tstart % 60);
              }

              if (tstart <= tnow && tend >= tnow) {
                it.filled_rectangle(6, l+2, w-m, lh+2);
                it.printf(m*2, l, id(small_font), WHITE, BLACK, TextAlign::TOP_LEFT, "%02d:%02d %s", tstart / 60, tstart % 60, title.c_str());  
              } else if (count > 1 && id(next_agenda_start) == tstart && id(next_agenda_start) > tnow) {
                it.filled_rectangle(6, l+2, w-m, 2); // Thick line
              }

              l += lh;
            }
          }
          if (overLimit > 0) {
            it.printf(w-m*2, l-lh, id(small_font), TextAlign::TOP_RIGHT, "+%d", overLimit);
          }
        }
      }

graphical_display_menu:
  # https://esphome.io/components/display_menu/
  id: menu
  active: true
  mode: rotary
  font: small_font
  items:
    - type: menu
      text: !lambda |-
        if (id(alarm_a_enable).state) {
          char buffer[20];
          snprintf(buffer, 20, "Alarm A (%.0f:%02.0f)", id(alarm_a_hour).state, id(alarm_a_min).state);
          return buffer;
        }
        return "Alarm A (Off)";
      items:
        - type: back
          text: "<< [Alarm A]"
        - type: switch
          text: "Enable"
          switch: alarm_a_enable
          immediate_edit: true
        - &alarmItem
          text: "Hour"
          number: alarm_a_hour
          type: number
          format: "%02.0f"
          on_value:
            then:
              lambda: id(alarm_a_enable).turn_on();
        - <<: *alarmItem
          text: "Minute"
          number: alarm_a_min

    - type: menu
      text: !lambda |-
        if (id(alarm_b_enable).state) {
          char buffer[20];
          snprintf(buffer, 20, "Alarm B (%.0f:%02.0f)", id(alarm_b_hour).state, id(alarm_b_min).state);
          return buffer;
        }
        return "Alarm B (Off)";
      items:
        - type: back
          text: "<< [Alarm B]"
        - type: switch
          text: "Enable"
          switch: alarm_b_enable
          immediate_edit: true
        - <<: *alarmItem
          text: "Hour"
          number: alarm_b_hour
        - <<: *alarmItem
          text: "Minute"
          number: alarm_b_min

    - type: command
      text: Refresh weather
      on_value:
        then:
          lambda: |-
            if (id(wi_fi).is_disabled()) {
              id(wi_fi).enable();
            } else {
              id(mode) = $MODE_FACES;
              id(request_weather).turn_on();
              id(update_weather).execute();
              id(ntp).update();
              id(epaper).update();
            }

    - type: command
      text: "Today's Agenda"
      on_value:
        then:
          lambda: |-
            id(mode) = $MODE_AGENDA;

    - type: switch
      text: Power save
      switch: power_saving_mode
      immediate_edit: true

    - text: "Clock interval"
      number: clock_interval_minutes
      type: number
      format: "%2.0f"
      value_lambda: |-
        return (id(clock_interval_minutes).state == 0 ? "1" : std::to_string(int(id(clock_interval_minutes).state))) + "m";

    - type: command
      text: "QR Contact Card"
      on_value:
        then:
          lambda: |-
            id(mode) = $MODE_QR;

    - type: command
      # Home Assistant example service call.
      # https://esphome.io/components/api.html
      text: HA Example
      on_value:
        then:
          - homeassistant.service:
              service: notify.notify # Change this as you need, eg. any automation or scene
              data:
                message: Hello from Watchy!

binary_sensor:
  # https://esphome.io/components/binary_sensor
  # https://esphome.io/components/binary_sensor/gpio

  ## Upper Left ##

  - id: power_on_button
    pin:
      number: $BUTTON_LEFT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            if (id(alarm_buzzing)) {
              id(alarm_buzzing) = false;
              id(buzzer).turn_off();
            } else {
              id(sleep_timeout) = $WAKE_TIME;
              if (id(mode) != $MODE_FACES) {
                id(mode) = $MODE_FACES;
                id(menu).show_main();
              } else if (id(wi_fi).is_disabled()) {
                id(wi_fi).enable();
              }
            }
            id(epaper).update();

  - id: power_saving_mode_button
    pin:
      number: $BUTTON_LEFT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 3s
    on_press:
      - lambda: |-
          if (id(mode) == $MODE_FACES) {
            id(power_saving_mode).turn_on();
            id(sleep_timeout) = 0;
            id(wi_fi).disable();
            id(epaper).update();
            id(conditional_sleep).execute();
          }

  ## Lower Left ##

  - id: timer_button
    pin:
      number: $BUTTON_LEFT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            id(sleep_timeout) = $WAKE_TIME;
            if (id(mode) == $MODE_MENU) {
              id(menu).enter();
            } else if (id(mode) == $MODE_TIMERS || id(timers)[0] == 0) {
              id(mode) = $MODE_TIMERS;
              if (id(timers)[id(active_timer)] != 0) {
                id(active_timer) = (id(active_timer) + 1) % 5;
              }
              id(timers)[id(active_timer)] = id(ntp).utcnow().timestamp;
            } else {
              id(mode) = $MODE_TIMERS;
            }
            id(epaper).update();

  - id: cancel_active_timer_button
    pin:
      number: $BUTTON_LEFT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 3s
    on_press:
      - lambda: |-
          id(sleep_timeout) = $WAKE_TIME;
          if (id(mode) == $MODE_TIMERS) {
            id(mode) = $MODE_TIMERS;
            id(timers)[id(active_timer)] = 0;
            if (id(active_timer) != 0) {
              id(active_timer) -= 1;
            }
            id(epaper).update();
          } else if (id(mode) == $MODE_MENU) {
            id(menu).show_main();
          }

  - id: clear_all_timers_button
    pin:
      number: $BUTTON_LEFT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 4s
    on_press:
      - lambda: |-
          id(sleep_timeout) = $WAKE_TIME;
          if (id(mode) == $MODE_TIMERS) {
            id(mode) = $MODE_TIMERS;
            id(active_timer) = 0;
            id(timers)[0] = 0;
            id(timers)[1] = 0;
            id(timers)[2] = 0;
            id(timers)[3] = 0;
            id(timers)[4] = 0;
            id(epaper).update();
          }

  ## Upper Right ##

  - id: face_cycle_button
    pin:
      number: $BUTTON_RIGHT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            id(sleep_timeout) = $WAKE_TIME;
            if (id(mode) == $MODE_MENU) {
              id(menu).up();
            } else if (id(mode) == $MODE_FACES) {
              id(face) = (id(face) + 1) % $FACE_COUNT;
            } else if (id(mode) == $MODE_QR) {
              id(qr_mode) = (id(qr_mode) + 1) % 3;
            } else {
              id(mode) = $MODE_FACES;
            }
            id(epaper).update();

  - id: calendar_agenda_mode_button
    pin:
      number: $BUTTON_RIGHT_TOP_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 3s
    on_press:
      - lambda: |-
          id(sleep_timeout) = $WAKE_TIME;
          id(mode) = $MODE_AGENDA;
          id(epaper).update();

  ## Lower Right ##

  - id: menu_mode_button
    pin:
      number: $BUTTON_RIGHT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    on_click:
      min_length: 0ms
      max_length: 2s
      then:
        - lambda: |-
            id(sleep_timeout) = $WAKE_TIME;
            if (id(mode) == $MODE_MENU) {
              id(menu).down();
            } else {
              id(mode) = $MODE_MENU;
            }
            id(epaper).update();

  - id: full_epaper_refresh_button
    pin:
      number: $BUTTON_RIGHT_BOTTOM_PIN
      allow_other_uses: true
      inverted: $BUTTON_PIN_INVERTED
    platform: gpio
    filters:
      delayed_on: 3s
    on_press:
      - lambda: |-
          id(sleep_timeout) = $WAKE_TIME;
          id(epaper).do_full_update();
          id(epaper).update();

  ## Charging ##
  - id: is_charging
    pin:
      # number: $CHRG_STATUS_PIN # Does not seem to work
      number: $USB_DET_PIN
      # inverted: true
    platform: gpio
    ## This pin seems to be unstable and can flip randomly, causing too many epaper updates:
    # on_state:
    #   component.update: epaper

wifi:
  # https://esphome.io/components/wifi.html
  # https://esphome.io/components/wifi.html#connecting-to-multiple-networks
  id: wi_fi
  power_save_mode: HIGH
  enable_on_boot: false
  ssid: $WIFI_SSID
  password: $WIFI_PASSWORD
  fast_connect: true
  reboot_timeout: 0s
  on_connect:
    - delay: 100ms
    - lambda: |-
        id(epaper).update();
        const auto now = id(ntp).now();
        if (now.hour == 0 && now.minute == 0 || !now.is_valid()) {
          id(ntp).update();
        }
        if ($ENABLE_WEATHER_API && id(request_weather).state) {
          id(update_weather).execute();
        }

improv_serial:
  # https://esphome.io/components/improv_serial.html
  # This component allows wifi to be set by https://web.esphome.io/

script:
  # https://esphome.io/components/script.html

  - id: alarms
    mode: single
    then:
      lambda: |-
        const auto now = id(ntp).now();
        int x = 0;

        id(chime) = !id(power_saving_mode).state && now.minute == 0
          && (now.hour == 8 || now.hour == 12 || now.hour == 16);

        if (
          (id(alarm_a_enable).state && int(id(alarm_a_hour).state) == now.hour && int(id(alarm_a_min).state) == now.minute) ||
          (id(alarm_b_enable).state && int(id(alarm_b_hour).state) == now.hour && int(id(alarm_b_min).state) == now.minute)
        ) {
          x = 3;
        }

        const int tnow = now.hour * 60 + now.minute;

        if (id(next_agenda_start) > 0) {
          const int nextAgendaDuration = id(next_agenda_end) - id(next_agenda_start);

          if (
            // Calendar agenda alarms:
            id(next_agenda_start) == tnow
            || (id(next_agenda_start) == tnow + $AGENDA_REMINDER_1 && nextAgendaDuration >= $AGENDA_REMINDER_1 / 2)
            || (id(next_agenda_start) == tnow + $AGENDA_REMINDER_2 && nextAgendaDuration >= $AGENDA_REMINDER_2 / 2)
          ) {
            id(agenda_alarm_time) = id(next_agenda_start);
            x = 2;
          }
          
          if (id(next_agenda_start) == tnow || id(next_agenda_end) <= tnow) {
            // Previous reminder expired, so re-parse agenda JSON:
            id(parse_agenda).execute();
          }
        }

        if (x != 0) {
          id(alarm_buzzing) = true;
          if (x > id(sleep_timeout)) {
            id(sleep_timeout) = x;
          }
        }

  - id: alarm_buzzer
    mode: single
    then:
      - if:
          condition:
            lambda: return id(alarm_buzzing);
          then:
            - switch.turn_on: buzzer
            - delay: 250ms
            - switch.turn_off: buzzer
            - delay: 200ms
            - switch.turn_on: buzzer
            - delay: 250ms
            - switch.turn_off: buzzer

  - id: parse_agenda
    mode: single
    then:
      lambda: |-
        // Parse the JSON agenda and set next_agenda_start and next_agenda_title globals.

        DynamicJsonDocument doc($AGENDA_JSON_BYTES);
        DeserializationError jsonErr = deserializeJson(doc, id(agenda));

        const int prevAgendaTime = id(next_agenda_start);

        id(next_agenda_start) = -1;
        id(next_agenda_end) = -1;
        id(next_agenda_title) = "";

        if (jsonErr == DeserializationError::Ok) {
          const auto now = id(ntp).now();
          const int tnow = now.hour * 60 + now.minute;

          for (JsonArray elem : doc.as<JsonArray>()) {
            const int tstart = elem[0].as<int>();
            const int tend = elem[1].as<int>();
            const String title = elem[2].as<String>();

            if (
              tstart == 0 && tend == 1440 && id(next_agenda_start) == -1
              || tstart > tnow && id(next_agenda_start) <= tnow
              || tend > tnow && id(next_agenda_start) <= tnow
            ) {
              id(next_agenda_start) = tstart;
              id(next_agenda_end) = tend;
              id(next_agenda_title) = title.substring(0, tstart == 0 && tend == 1440 ? 20 : 12).c_str();
            }
          }

          if (
            prevAgendaTime == -1 && id(next_agenda_start) != -1
          ) {
            // There are new agenda items so update the display mode:
            id(mode) = $MODE_AGENDA;
            id(epaper).update();
          }
        }

  - id: update_weather
    mode: single
    then:
      - lambda: |-
          ESP_LOGI("watchy", "Weather HTTP request");
      - http_request.get:
          # https://esphome.io/components/http_request.html#http-request-get-action
          # https://openweathermap.org/forecast5
          url: http://api.openweathermap.org/data/2.5/forecast?cnt=4&id=$WEATHER_CITY_ID&units=$UNITS&lang=$LANG&appid=$WEATHER_KEY
          headers:
            Content-Type: application/json
          capture_response: true
          max_response_buffer_size: 3kB
          on_response:
            then:
              lambda: |-
                // TODO: Test if response is 200
                // ESP_LOGI("watchy", "Weather status %d %ums.", status_code, duration_ms);
                ESP_LOGI("watchy", "Weather HTTP response");
                id(parse_weather).execute(body);

  - id: parse_weather
    mode: restart
    parameters:
      body: string
    then:
      lambda: |-
        ESP_LOGI("watchy", "Parse weather body");

        json::parse_json(body, [](JsonObject root) -> bool {
          float tMin = 1000.0;
          float tMax = -1000.0;

          for (int x=0; x<=3; ++x) {
            id(weather_times)[x] = int(root["list"][x]["dt"]) + 90 * 60; // Add 90min (50%) to expiry time
            id(weather_codes)[x] = weatherCode(root["list"][x]["weather"][0]["id"], root["list"][x]["sys"]["pod"]);
            ESP_LOGI("watchy", "Weather code %d @ %d", id(weather_codes)[x], id(weather_times)[x]);
            tMin = min(tMin, float(root["list"][x]["main"]["feels_like"])); // or temp_min
            tMax = max(tMax, float(root["list"][x]["main"]["feels_like"])); // or temp_max
          }

          id(weather_temp_min) = tMin;
          id(weather_temp_max) = tMax;

          ESP_LOGI("watchy", "Weather min: %.1f, max: %.1f", id(weather_temp_min), id(weather_temp_max));

          return true;
        });

        id(request_weather).turn_off();

        if (id(mode) == $MODE_FACES) {
          id(epaper).update();
          id(epaper).do_full_update();
          id(epaper).update();
        }

  - id: conditional_sleep
    mode: restart
    then:
      - if:
          condition:
            lambda: return id(sleep_timeout) <= 0;
          then:
            - lambda: |-
                id(request_weather).turn_off();
                id(buzzer).turn_off();
                if (id(mode) == $MODE_MENU) {
                  id(mode) = $MODE_FACES;
                }
                if (id(sleep_timeout) == 0) {
                  id(wi_fi).disable();
                  id(epaper).update();
                }
            - deep_sleep.enter:
                # TODO: How to call id(deep_sleep).enter() with sleep_duration in C++?
                sleep_duration: !lambda |-
                  const int s = calcSleepTimeSeconds(
                    id(power_saving_mode).state,
                    id(clock_interval_minutes).state,
                    id(ntp).now()
                  );
                  if (s == 0) {
                    return 1 * 60 * 1000; // milliseconds
                  } else {
                    return s * 1000; // milliseconds
                  }

time:
  # https://esphome.io/components/time/index.html
  # https://esphome.io/components/time/sntp

  - id: ntp
    platform: sntp
    timezone: $TIME_ZONE
    servers:
      - $SNTP_SERVER_1
      - $SNTP_SERVER_2
      - $SNTP_SERVER_3
    on_time_sync:
      # https://esphome.io/components/time/index.html#time-on-time-sync
      if:
        condition:
          - wifi.connected:
          - lambda: "return id(ntp).now().is_valid();"
        then:
          # - pcf8563.write_time: # Only for Watchy v2
          - component.update: epaper
    on_time:
      # https://esphome.io/components/time/index.html#time-on-time
      - seconds: 0
        then:
          - lambda: |-
              id(sleep_timeout) -= 1;
              id(alarms).execute();
              id(epaper).update();
              id(buzzer).turn_off();
              id(conditional_sleep).execute();
      - seconds: /10
        then:
          script.execute: alarm_buzzer

  ## https://esphome.io/components/time/pcf8563.html
  # - platform: pcf8563 # Only for Watchy v2
  #   id: pcf
  #   update_interval: never
  #   address: 0x51

deep_sleep:
  # https://esphome.io/components/deep_sleep.html
  wakeup_pin_mode: INVERT_WAKEUP
  wakeup_pin:
    number: $BUTTON_LEFT_TOP_PIN
    inverted: $BUTTON_PIN_INVERTED
    allow_other_uses: true

globals:
  # https://esphome.io/components/globals.html
  - id: sleep_timeout
    type: int
    initial_value: "-1"
  - id: chime
    type: boolean
    initial_value: "false"
  - id: alarm_buzzing
    type: boolean
    initial_value: "false"
  - id: agenda_alarm_time
    type: int
    initial_value: "-1"
  ## Persistent ##
  # These following variables will be preserved (saved in flash memory) even after the ESP32 reboots
  - id: face
    type: int
    restore_value: yes
    initial_value: "0"
  - id: mode
    type: int
    restore_value: yes
    initial_value: "0"
  - id: qr_mode
    type: int
    restore_value: yes
    initial_value: "0"
  - id: weather_codes
    type: int[4]
    restore_value: yes
    initial_value: "{800, 210, 502, 1800}"
  - id: weather_times
    type: int[4]
    restore_value: yes
    initial_value: "{2019646800, 2019646800, 2019646800, 2019646800}"
  - id: weather_temp_min
    type: float
    restore_value: yes
    initial_value: "14"
  - id: weather_temp_max
    type: float
    restore_value: yes
    initial_value: "25"
  - id: active_timer
    type: int
    restore_value: yes
    initial_value: "0"
  - id: timers
    type: int[5]
    restore_value: yes
  - id: agenda
    type: std::string
    restore_value: yes
    max_restore_data_length: 254
    initial_value: '""'
  - id: next_agenda_start
    type: int
    restore_value: yes
    initial_value: "-1"
  - id: next_agenda_end
    type: int
    restore_value: yes
    initial_value: "-1"
  - id: next_agenda_title
    type: std::string
    restore_value: yes
    max_restore_data_length: 32
    initial_value: '""'

font:
  # https://esphome.io/components/display/fonts.html

  # https://freefonts.co/fonts/futura-bold

  - id: small_font
    file: "fonts/Futura Bold/Futura Bold.otf"
    # file: "gfonts://Inter@400"
    # file: "gfonts://Atkinson+Hyperlegible@400"
    size: 16
    glyphs: "+@[]<>().,:°'’!?-/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz"
    bpp: 2

  - id: date_font
    file: "fonts/Futura Bold/Futura Bold.otf"
    size: 28
    glyphs: "!:°'-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz"
    bpp: 2

  - id: time_font
    file: "fonts/Futura Bold/Futura Bold.otf"
    size: 64
    glyphs: ":0123456789-"
    bpp: 2

  # https://github.com/Templarian/MaterialDesign-Webfont/tree/master/fonts
  # These icon codes are defined in ./mdi.yaml
  # mdi.yaml is regenerated/updated by running `node generate-mdi.js`

  - id: mdi_small
    file: fonts/mdi/fonts/materialdesignicons-webfont.woff
    size: 26
    glyphs:
      # See ./mdi.yaml
      - "$mdiAccountBox"
      - "$mdiAlarmCheck"
      - "$mdiArrowDownThin"
      - "$mdiArrowLeftTop"
      - "$mdiArrowUpThin"
      - "$mdiBatteryHigh"
      - "$mdiBatteryLow"
      - "$mdiBatteryMedium"
      - "$mdiBatteryOutline"
      - "$mdiBatteryRemoveOutline"
      - "$mdiBellBadgeOutline"
      - "$mdiBellOutline"
      - "$mdiBellRingOutline"
      - "$mdiCalendarClock"
      - "$mdiCheckCircleOutline"
      - "$mdiCloudDownloadOutline"
      - "$mdiEmoticonHappyOutline"
      - "$mdiHomeAssistant"
      - "$mdiRssBox"
      - "$mdiSleep"
      - "$mdiTimerOutline"
      - "$mdiUsbPort"
      - "$mdiWebBox"
      - "$mdiWifi"
      - "$mdiWifiAlert"
      - "$mdiWifiOff"

  - &mdi_weather
    id: mdi_weather
    file: fonts/mdi/fonts/materialdesignicons-webfont.woff
    size: 36
    glyphs:
      # See ./mdi.yaml
      - "$mdiAlert"
      - "$mdiWeatherCloudy"
      - "$mdiWeatherCloudyAlert"
      - "$mdiWeatherCloudyArrowRight"
      - "$mdiWeatherDust"
      - "$mdiWeatherFog"
      - "$mdiWeatherHail"
      - "$mdiWeatherHazy"
      - "$mdiWeatherHurricane"
      - "$mdiWeatherLightning"
      - "$mdiWeatherLightningRainy"
      - "$mdiWeatherNight"
      - "$mdiWeatherNightPartlyCloudy"
      - "$mdiWeatherPartlyCloudy"
      - "$mdiWeatherPartlyLightning"
      - "$mdiWeatherPartlyRainy"
      - "$mdiWeatherPartlySnowy"
      - "$mdiWeatherPartlySnowyRainy"
      - "$mdiWeatherPouring"
      - "$mdiWeatherRainy"
      - "$mdiWeatherSnowy"
      - "$mdiWeatherSnowyHeavy"
      - "$mdiWeatherSnowyRainy"
      - "$mdiWeatherSunny"
      - "$mdiWeatherSunnyAlert"
      - "$mdiWeatherSunnyOff"
      - "$mdiWeatherSunset"
      - "$mdiWeatherSunsetDown"
      - "$mdiWeatherSunsetUp"
      - "$mdiWeatherTornado"
      - "$mdiWeatherWindy"
      - "$mdiWeatherWindyVariant"

  - <<: *mdi_weather
    id: mdi_weather_big
    size: 64

  - <<: *mdi_weather
    id: mdi_weather_very_big
    size: 96

  - <<: *mdi_weather
    id: mdi_weather_huge
    size: 146

  - id: mdi
    file: fonts/mdi/fonts/materialdesignicons-webfont.woff
    size: 36
    glyphs:
      - "$mdiAirballoon"
      - "$mdiBee"
      - "$mdiBicycle"
      - "$mdiBird"
      - "$mdiCakeVariantOutline"
      - "$mdiCastle"
      - "$mdiCity"
      - "$mdiCityVariant"
      - "$mdiClover"
      - "$mdiCodeBraces"
      - "$mdiCreationOutline"
      - "$mdiDeathStarVariant"
      - "$mdiDebugStepOver"
      - "$mdiDonkey"
      - "$mdiEarth"
      - "$mdiElephant"
      - "$mdiEmoticonHappyOutline"
      - "$mdiFerry"
      - "$mdiForest"
      - "$mdiGoogleDownasaur"
      - "$mdiHalloween"
      - "$mdiHeart"
      - "$mdiHelicopter"
      - "$mdiHospitalBuilding"
      - "$mdiHumanMaleBoard"
      - "$mdiHumanMaleChild"
      - "$mdiLinkBoxVariant"
      - "$mdiMedal"
      - "$mdiOfficeBuilding"
      - "$mdiPartyPopper"
      - "$mdiPeace"
      - "$mdiPineTree"
      - "$mdiPlusThick"
      - "$mdiRocketLaunch"
      - "$mdiSatelliteVariant"
      - "$mdiSchool"
      - "$mdiSpaceInvaders"
      - "$mdiSpaceStation"
      - "$mdiStarOutline"
      - "$mdiStarShootingOutline"
      - "$mdiTeddyBear"
      - "$mdiUfoOutline"
      - "$mdiVote"
      - "$mdiWater"

esp32:
  # https://esphome.io/components/esp32.html
  board: esp32-s3-devkitc-1
  flash_size: 8MB
  # https://raw.githubusercontent.com/espressif/arduino-esp32/master/tools/partitions/default_8MB.csv
  partitions: default_8MB.csv
  variant: esp32s3

sensor:
  # https://esphome.io/components/sensor/index.html
  # https://esphome.io/components/sensor/adc.html
  - platform: adc
    id: battery
    attenuation: auto
    pin: $BATTERY_ADC_PIN
    update_interval: never
    filters:
      - multiply: $BATTERY_VOLTAGE_DIVIDER

switch:
  # https://esphome.io/components/switch/index.html
  # https://esphome.io/components/switch/gpio.html
  # https://esphome.io/components/switch/template.html

  - platform: gpio
    id: buzzer
    pin: $VIB_MOTOR_PIN

  - &alarm_enable
    platform: template
    id: alarm_a_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - <<: *alarm_enable
    id: alarm_b_enable

  - platform: template
    id: power_saving_mode
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    id: request_weather
    name: Watchy $ID Request Weather
    optimistic: true

  - platform: template
    id: api_connected
    name: Watchy $ID Connected
    optimistic: true

number:
  # https://esphome.io/components/number/template.html
  - &alarmHour
    platform: template
    id: alarm_a_hour
    optimistic: true
    restore_value: true
    min_value: 0
    initial_value: 12
    max_value: 23
    step: 1

  - &alarmMin
    platform: template
    id: alarm_a_min
    optimistic: true
    restore_value: true
    min_value: 0
    initial_value: 0
    max_value: 59
    step: 10 ## Step size must be a multiple of 5

  - <<: *alarmHour
    id: alarm_b_hour

  - <<: *alarmMin
    id: alarm_b_min

  - platform: template
    id: clock_interval_minutes
    optimistic: true
    restore_value: true
    min_value: 0
    initial_value: 0
    max_value: 10 ## Maximum cannot be more than alarm_a_min step above
    step: 5 ## Step size must be a multiple of 5

i2c:
  # https://esphome.io/components/i2c.html
  scan: false
  sda: $I2C_SDA_PIN
  scl: $I2C_SCL_PIN

spi:
  # https://esphome.io/components/spi.html
  # SPI is used by the ePaper display
  # SPI_SS_PIN ??
  mosi_pin: $SPI_MOSI_PIN
  miso_pin: $SPI_MISO_PIN
  clk_pin: $SPI_SCK_PIN

ota:
  # https://esphome.io/components/ota/
  password: $OTA_PASSWORD
  platform: esphome

http_request:
  # https://esphome.io/components/http_request.html#
  id: http_request_data
  verify_ssl: false

qr_code:
  # https://esphome.io/components/display/index.html

  - id: qr_vcard
    ecc: LOW
    value: $QR_VCARD

  - id: qr_website
    ecc: LOW
    value: $QR_WEBSITE_URL

  - id: qr_rss
    ecc: LOW
    value: $QR_RSS_URL

external_components:
  # https://esphome.io/components/external_components.html
  # This project used a slightly modified module forked from the main ESPHome project.
  # The minor customisations for Watchy are:
  #  Prevent a full ePaper refresh on ESP32 boot which is not the desired behaviour for a low-power watch.
  #   https://github.com/multipolygon/esphome/commit/6407a74ff9855d515cb16fef67f90c748f9800ea
  #  Add a pubic `do_full_update()` method to trigger the full-refresh only at certain times of day - a full update clears away ghost pixels.
  #   https://github.com/multipolygon/esphome/commit/ecf116058cc4b20007126f9099f4b07f4d46b9dd
  - components: [waveshare_epaper]
    source:
      # type: local
      # path: ../esphome/esphome/components
      type: git
      url: https://github.com/multipolygon/esphome
      ref: dev

api:
  # https://esphome.io/components/api.html
  reboot_timeout: 0s
  encryption:
    key: $HOME_ASSISTANT_API_KEY
  on_client_connected:
    - lambda: |-
        ESP_LOGI("watchy", "API connected!");
    - delay: 1s
    - lambda: |-
        id(api_connected).turn_on();
  actions:
    - service: set_weather
      variables:
        weather_json: string
      then:
        lambda: |-
          ESP_LOGI("watchy", "set_weather");
          id(parse_weather).execute(weather_json);

    - service: set_agenda
      variables:
        agenda_json: string
      then:
        lambda: |-
          ESP_LOGI("watchy", "set_agenda");
          id(agenda) = agenda_json;
          id(parse_agenda).execute();
          id(epaper).update();
